<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="baizn的github博客">
<meta property="og:url" content="http://baizn.github.io/index.html">
<meta property="og:site_name" content="baizn的github博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="baizn的github博客">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://baizn.github.io/"/>

  <title> baizn的github博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">baizn的github博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/22/前端路由实现原理/" itemprop="url">
                  前端路由实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-06-22T18:03:30+08:00" content="2016-06-22">
              2016-06-22
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以hash形式为例，当URL的hash发生变化时，就会触发hashchange事件，此时可以在该事件的回调方法中进行不同的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Router</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">	<span class="keyword">this</span>.currentUrl = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Router.prototype = &#123;</span><br><span class="line">	route: <span class="function"><span class="keyword">function</span>(<span class="params">path, callback</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.routes[path] = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.currentUrl = location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">		<span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl]();</span><br><span class="line">	&#125;,</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.Router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="built_in">window</span>.Router.init();</span><br></pre></td></tr></table></figure>
<p>上面的Router主要提供了三个方法。</p>
<ul>
<li>init：监听浏览器URL hash事件</li>
<li>route：存储路由更新时的URL及回调函数到routes数组中，回调函数负责完成对页面的更新</li>
<li>refresh：执行当前URL对应的回调函数，更新页面</li>
</ul>
<p>使用Router的基本示例如下。</p>
<p><strong>HTML</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">'#/'</span>&gt;</span>home<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">'#/about'</span>&gt;</span> about <span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>JS</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Router.route(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'home'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Router.route(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'about'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>参考资料</strong></p>
<p><a href="https://github.com/joeyguo/blog/issues/2" target="_blank" rel="external">前端路由实现与 react-router 源码分析</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/06/ES6中改良的JS缺陷/" itemprop="url">
                  ES6中改良的JS缺陷
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-06-06T16:33:35+08:00" content="2016-06-06">
              2016-06-06
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="块级作用域">块级作用域</h3><p>ES5只有函数作用域，ES6提供了let和const来代替var声明变量，新的声明方式支持用大括号表示的块级作用域。</p>
<ul>
<li>防止变量在作用域外被访问</li>
<li>防止重复声明变量：ES6不允许在同一个作用域内用let或const重复声明同名变量</li>
<li>不再需要立即执行的函数表达式</li>
<li>Babel</li>
<li>循环体中的闭包不再有问题</li>
</ul>
<h3 id="词法作用域的this（通过箭头函数）">词法作用域的this（通过箭头函数）</h3><p>在ES5中，this会随着函数调用位置和调用方式改变，ES6通过箭头函数带来的词法作用域的this消除了这个问题。</p>
<p>词法作用域的this特性让变量的this总是指向词法声明时的那个对象。</p>
<h3 id="处理arguments">处理arguments</h3><p>ES5中，arguments表现的像一个数组，但不是真的数组，所以，一切数组方法如sort、slice等都用不了。</p>
<p>ES6中，可以使用一个新的特性叫做rest参数，它的形式为：<strong>…参数名（如…args）</strong>。rest参数是一个真正的数组。</p>
<h3 id="类">类</h3><p>ES6之前，JS中没有类的概念，只能把使用new关键字通过函数构造对象当作类来使用。</p>
<p>ES6带来了新的语法，与其他各种编程语言类似的语法，使得面向对象变的非常简单。</p>
<h3 id="严格模式">严格模式</h3><p>ES5中，严格模式是可选的，ES6中，许多特性都要求必须使用严格模式。</p>
<hr>
<p>参考资料：<a href="http://www.zcfy.cc/article/315?f=tt" target="_blank" rel="external">在ES6中改良的5个JavaScript缺陷</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/call-apply-bind详解/" itemprop="url">
                  call & apply & bind详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-06-02T09:25:03+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>call()方法的作用和apply()方法类似，只有一个区别，就是call()方法接受的是若干参数的列表，而apply()方法接受的是一个包含多个参数的数组。</p>
<h2 id="Function-prototype-call()">Function.prototype.call()</h2><p>call()方法在使用一个指定this值和若干个指定的参数值的前提下调用某个函数或方法。</p>
<h3 id="语法">语法</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span>.<span class="title">call</span></span>(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>
<h3 id="参数">参数</h3><p><strong>thisArg</strong></p>
<p>在fun函数运行时指定的this值。指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的this会指向该原始值的自动包装对象。</p>
<p><strong>arg1, arg2</strong></p>
<p>指定的参数列表。</p>
<h3 id="描述">描述</h3><p>当调用一个函数时，可以赋值一个不同的this对象。this引用当前对象，即call方法的第一个参数。</p>
<p>通过call方法，可以在一个对象上借用另一个对象上的方法，如Object.prototype.toString.call([])，就是一个Array对象借用了Object对象上的方法。</p>
<h3 id="示例">示例</h3><h4 id="使用call方法调用父构造函数">使用call方法调用父构造函数</h4><p>在一个子构造函数中，你可以通过调用父构造函数的call方法来实现继承，类似于java中的写法。下例中，使用Food和Toy构造函数创建的对象实例都会拥有在Product构造函数中添加的name属性和price属性，但category属性是各自的构造函数中定义的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.price = price;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">	Product.call(<span class="keyword">this</span>, name, price);</span><br><span class="line">	<span class="keyword">this</span>.category = <span class="string">'food'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Food.prototype = <span class="built_in">Object</span>.create(Product.prototype);</span><br><span class="line">Food.prototype.constructor = Food;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toy</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">	Product.call(<span class="keyword">this</span>, name, price);</span><br><span class="line">	<span class="keyword">this</span>.category = <span class="string">'toy'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Toy.prototype = <span class="built_in">Object</span>.create(Product.prototype);</span><br><span class="line">Toy.prototype.constructor = Toy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cheese = <span class="keyword">new</span> Food(<span class="string">'feta'</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Toy(<span class="string">'robot'</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="使用call方法调用匿名函数">使用call方法调用匿名函数</h4><p>在下例的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。这个匿名函数的主要目的是给每个元素对象添加一个print方法。这里不是必须得让数组元素作为this的值传入那个匿名函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">	&#123;</span><br><span class="line">		speicies: <span class="string">'Lions'</span>,</span><br><span class="line">		name: <span class="string">'king'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		speicies: <span class="string">'Whale'</span>,</span><br><span class="line">		name: <span class="string">'Fail'</span></span><br><span class="line">	&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = animals.length; i &lt; len; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'#'</span> + i + <span class="string">' '</span> + <span class="keyword">this</span>.species + <span class="string">' '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.print();</span><br><span class="line">	&#125;).call(anmials[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用call方法调用匿名函数并且指定上下文的this">使用call方法调用匿名函数并且指定上下文的this</h4><p>在下面的例子中，当调用greet方法时，该方法的this值会绑定到i对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> reply = [<span class="keyword">this</span>.person, <span class="string">'Is An Aesome'</span>, <span class="keyword">this</span>.role];</span><br><span class="line">	<span class="built_in">console</span>.log(reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = &#123;</span><br><span class="line">	person: <span class="string">'Douglas'</span>,</span><br><span class="line">	role: <span class="string">'JS'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">greet.call(i);</span><br></pre></td></tr></table></figure>
<h2 id="Function-prototype-apply()">Function.prototype.apply()</h2><p>apply()方法在指定this值和参数（参数以数组或类数组对象的形式存在）的情况下调用某个函数。</p>
<h3 id="语法-1">语法</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span>.<span class="title">apply</span></span>(thisArg[, argsArray])</span><br></pre></td></tr></table></figure>
<h3 id="参数-1">参数</h3><p><strong>thisArg</strong></p>
<p>在fun函数运行时指定的this值。指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null或undefined时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字、字符串、布尔值）的this会指向该原始值的自动包装对象。</p>
<p><strong>argsArray</strong></p>
<p>一个数组或者类数组对象，其中的数组元素将作为单独的参数传给fun函数。如果该参数的值为null或undefined，则表示不需要传入任何参数。从ES5开始，可以使用类数组对象。</p>
<h3 id="描述-1">描述</h3><p>在调用一个存在的函数时，你可以为其指定一个this对象。this指当前对象，也就是正在调用这个函数的对象。使用apply，你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。</p>
<p>apply可以使用数组字面量，如fun.apply(this, [‘eat’, ‘ban’])，或数组对象，如fun.apply(this, new Array(‘eat’, ‘ban’))。也可以使用arguments对象作为argsArray参数。arguments是一个函数的局部变量。它可以被用作调用对象的所有未指定的参数。这样，在使用apply函数的时候就不需要知道被调用对象的所有参数。可以使用arguments来把所有参数传递给被调用对象。</p>
<h3 id="示例-1">示例</h3><h4 id="使用apply来链接构造器">使用apply来链接构造器</h4><p>可以使用apply来给一个对象链接构造器，类似于Java。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span>(<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> oNew = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.prototype);</span><br><span class="line">	<span class="keyword">this</span>.apply(oNew, aArgs);</span><br><span class="line">	<span class="keyword">return</span> oNew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用下面的方式替换create方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span>(<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fc = <span class="keyword">this</span>, fNewConstr = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		fc.apply(<span class="keyword">this</span>, aArgs);</span><br><span class="line">	&#125;;</span><br><span class="line">	fNewConstr.prototype = fc.prototype;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> fNewConstr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用apply和内置函数">使用apply和内置函数</h4><p>apply用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> numbers = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">max</span> = Math.<span class="built_in">max</span>.apply(<span class="built_in">null</span>, numbers);</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">min</span> = Math.<span class="built_in">min</span>.apply(<span class="built_in">null</span>, numbers);</span><br></pre></td></tr></table></figure>
<p>如果数组很大，可以继续优化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minOfArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> min = <span class="literal">Infinity</span>;</span><br><span class="line">	<span class="keyword">var</span> QUANTUM = <span class="number">32768</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">var</span> submin = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, arr.slice(i, <span class="built_in">Math</span>.min(i + QUANTUM, len)));</span><br><span class="line">		min = <span class="built_in">Math</span>.min(submin, min);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> min = minOfArray(numbers);</span><br></pre></td></tr></table></figure>
<h2 id="Function-pototype-bind()">Function.pototype.bind()</h2><p>bind()方法会创建一个新函数，当这个函数被调用时，它的this值是传递给bind()的第一个参数，它的参数是 bind()的其它参数和其它原本的参数。</p>
<h3 id="语法-2">语法</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span>.<span class="title">bind</span></span>(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>
<h3 id="参数-2">参数</h3><p><strong>thisArg</strong></p>
<p>当绑定函数被调用时，该参数会作为原函数运行时的this指向。当使用new操作符调用绑定函数时，该参数无效。</p>
<p><strong>arg1, arg2, …</strong></p>
<p>当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数。</p>
<h3 id="描述-2">描述</h3><p>bind()函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体。当目标函数被调用时this值绑定到bind()的第一个参数，该参数不能被重写。绑定函数被调用时，bind()也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给模拟函数。</p>
<h3 id="示例-2">示例</h3><h4 id="创建绑定函数">创建绑定函数</h4><p>bind()函数最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">	x: <span class="number">80</span>,</span><br><span class="line">	getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">//80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line">retrieveX(); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line">boundGetX(); <span class="comment">//80</span></span><br></pre></td></tr></table></figure>
<h4 id="分离函数">分离函数</h4><p>bind()另一个用法是使一个函数拥有预设的初始参数。这些参数作为bind的第二个参数跟在this后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们的后面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var list1 = <span class="built_in">list</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">var leadingList = <span class="built_in">list</span>.bind(undefined, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">var list2 = leadingList(); <span class="comment">//[37]</span></span><br><span class="line">var list3 = leadingList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [37, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h4 id="配合setTimeout">配合setTimeout</h4><p>默认情况下，使用window.setTimeout()时，this关键字会指向window对象。当使用类的方法时，需要this引用类的实例，需要显式地把this绑定到回调函数以便继续使用实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LateBloomer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.petalCount = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">12</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LateBloomer.prototype.bloom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">window</span>.setTimeout(<span class="keyword">this</span>.declare.bind(<span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LateBloomer.prototype.declare = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'I am a beautiful flower width '</span> + <span class="keyword">this</span>.petalCount + <span class="string">' petals'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flower = <span class="keyword">new</span> LateBloomer();</span><br><span class="line">flower.bloom();</span><br></pre></td></tr></table></figure>
<h4 id="快捷调用">快捷调用</h4><p>需要为一个特定的this值的函数创建一个捷径的时候，bind()方法很好用。</p>
<p>可以用Array.prototype.slice来将一个类似于数组的对象转成一个真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">slice.apply(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p>用bind()可以使这个过程变得简单。slice是Function.prototype的call()方法的绑定函数，并且将Array.prototype的slice()方法作为this的值。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unboundSlice = <span class="keyword">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">call</span>.<span class="title">bind</span><span class="params">(unboundSlice)</span>;</span></span><br><span class="line"></span><br><span class="line">slice(arguments);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/jQuery插件开发/" itemprop="url">
                  jQuery插件开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-05-12T11:13:56+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基于jQuery的插件开发">基于jQuery的插件开发</h3><p>类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法，jQuery的全局函数就是属于jQuery命名空间的函数；</p>
<h4 id="添加一个新的全局函数">添加一个新的全局函数</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.<span class="built_in">sum</span> = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时：jQuery.sum(1, 2) 或 $.sum(1, 2);</p>
<h4 id="增加多个全局函数">增加多个全局函数</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jQuery.<span class="built_in">sum</span> = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.dup = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用时同上。</p>
<h4 id="使用jQuery-extend(object)">使用jQuery.extend(object)</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">	<span class="built_in">sum</span>:<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	dup:<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a - b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="使用命名空间">使用命名空间</h4><p>为了避免函数名及变量名与其他jQuery插件冲突，我们可以添加自定义命名空间。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.String = &#123;</span><br><span class="line">	<span class="built_in">sum</span>:<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	dup:<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a - b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>采用命名空间的函数仍然是全局函数，调用时采用的方法：$.String.sum(1, 2)。</p>
<h3 id="对象级别的插件开发，即给jQuery对象添加方法。">对象级别的插件开发，即给jQuery对象添加方法。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">	$.fn.extend(&#123;</span><br><span class="line">		sum:<span class="function"><span class="keyword">function</span>(<span class="params">opt, callback</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">	$.fn.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>
<h4 id="接收options参数以控制插件的行为">接收options参数以控制插件的行为</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.fn.sum = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> defaults = &#123;</span><br><span class="line">		foreground:<span class="string">'red'</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> opts = $.extend(defaults, options);</span><br><span class="line">	<span class="comment">//插件具体功能</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="暴露插件的默认设置">暴露插件的默认设置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.fn.sum = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> opts = $.extend(&#123;&#125;, $.fn.sum.defaults, options);</span><br><span class="line">	<span class="comment">//插件的具体实现</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">$.fn.sum.defaults = &#123;</span><br><span class="line">	foreground:<span class="string">'red'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用者可以这样调用：$.fn.sum.defaults.foreground = ‘blue’;</p>
<p>这个只需要调用一次，且不需要在ready块中调用。<br>$(‘#id’).sum();</p>
<p>也可以通过传递配置参数给插件的方法来覆盖缺省设置：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#blue'</span>).<span class="keyword">sum</span>(&#123;</span><br><span class="line">	foreground:<span class="string">'blue'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="适当的暴露一些函数">适当的暴露一些函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.fn.sum = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//具体实现代码</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> markup = $<span class="keyword">this</span>.html();</span><br><span class="line">		markup = $.fn.sum.format(markup);</span><br><span class="line">		$<span class="keyword">this</span>.html(markup);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>//定义format函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.fn.sum.format = <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'&lt;strong&gt;'</span> + txt + <span class="string">'&lt;/strong&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="保持私有函数的私有性">保持私有函数的私有性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//插件定义</span></span><br><span class="line">	$.fn.sum = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">		debug(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//具体实现</span></span><br><span class="line">		...</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//私有函数定义</span></span><br><span class="line">	<span class="keyword">var</span> debug = <span class="function"><span class="keyword">function</span>(<span class="params">$obj</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">window</span>.console &amp;&amp; <span class="built_in">window</span>.console.log) &#123;</span><br><span class="line">			<span class="built_in">window</span>.console.log(<span class="string">'selection count:'</span> + $obj.size())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>
<h3 id="完整示例代码">完整示例代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//插件的定义</span></span><br><span class="line">	$.fn.hilight = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">		debug(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">var</span> opts = $.extend(&#123;&#125;, $.fn.hilight.defaults, options);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);</span><br><span class="line">			<span class="keyword">var</span> o = $.meta ? $.extend(&#123;&#125;, opts, $<span class="keyword">this</span>,data()) : opts;</span><br><span class="line">			<span class="comment">//更新元素样式</span></span><br><span class="line">			$<span class="keyword">this</span>.css(&#123;</span><br><span class="line">				backgroundColor:o.backround,</span><br><span class="line">				color:o.foreground</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">var</span> markup = $<span class="keyword">this</span>.html();</span><br><span class="line">			markup = $.fn.format(markup);</span><br><span class="line">			$<span class="keyword">this</span>.html(markup);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//私有函数</span></span><br><span class="line">	<span class="keyword">var</span> debug = <span class="function"><span class="keyword">function</span>(<span class="params">$obj</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">window</span>.console &amp;&amp; <span class="built_in">window</span>.console.log) &#123;</span><br><span class="line">			<span class="built_in">window</span>.console.log(<span class="string">'selection count:'</span> + $obj.size())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义暴露函数format</span></span><br><span class="line">	$.fn.hilight.format = <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'&lt;strong&gt;'</span> + txt + <span class="string">'&lt;/strong&gt;'</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插件的defaults</span></span><br><span class="line">	$.fn.hilight.defaults = &#123;</span><br><span class="line">		foreground:<span class="string">'red'</span>,</span><br><span class="line">		background:<span class="string">'yellow'</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/使用JS修改文本框样式/" itemprop="url">
                  使用JS修改文本框样式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-05-12T10:56:45+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="使用JavaScript修改文本框的样式">使用JavaScript修改文本框的样式</h3><p>当上传文件时，默认的文本框样式直接丑到哭，可以使用JS进行自定义样式。基本步骤如下：</p>
<blockquote>
<ul>
<li>隐藏掉type=file的输入框</li>
<li>自定义控件样式</li>
<li>定义事件，当点击自定义控件时，调用隐藏的输入框click事件</li>
</ul>
</blockquote>
<p>基本代码框架如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="class"><span class="keyword">type</span>=</span><span class="symbol">'fil</span>e' name=<span class="symbol">'fil</span>e' id=<span class="symbol">'fil</span>e' style=<span class="symbol">'display</span>: none;' /&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span>=</span><span class="symbol">'selfstyl</span>e'&gt;</span><br><span class="line">	&lt;input <span class="class"><span class="keyword">type</span>=</span><span class="symbol">'tex</span>t' id=<span class="symbol">'showur</span>l' <span class="class"><span class="keyword">class</span>=</span><span class="symbol">'inputstyl</span>e' disabled /&gt;</span><br><span class="line">	&lt;a <span class="class"><span class="keyword">class</span>=</span><span class="symbol">'btn</span> btn-info' id=<span class="symbol">'triggerFil</span>e'&gt;</span><br><span class="line">		&lt;i <span class="class"><span class="keyword">class</span>=</span><span class="symbol">'icon</span>-folder-open-alt'&gt;&lt;/i&gt;浏览</span><br><span class="line">	&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">$('#file').change(function() &#123;</span><br><span class="line">	<span class="keyword">var</span> path = $(<span class="keyword">this</span>).<span class="keyword">val</span>();</span><br><span class="line">	path = path.split('\\');</span><br><span class="line">	path = path[path.length - <span class="number">1</span>];</span><br><span class="line">	$('#showurl').<span class="keyword">val</span>(path);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/CSS实现全屏自适应/" itemprop="url">
                  CSS实现全屏自适应
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-05-12T10:54:05+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="CSS实现没有宽度和高度声明的全屏自适应效果">CSS实现没有宽度和高度声明的全屏自适应效果</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line">	<span class="tag">html</span>, <span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">		<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">	&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="class">.overlay</span> <span class="rules">&#123;</span><br><span class="line">		<span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#000</span></span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">0.5</span></span></span>;</span><br><span class="line">		<span class="rule"><span class="attribute">filter</span>:<span class="value"> <span class="function">alpha</span>(apacity=<span class="number">50</span>)</span></span>;</span><br><span class="line">	&#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"overlay"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于positiono为absolute或fixed的元素，同时设置left和right和width，即可margin:auto水平居中；同理可以设置top,bottom,height垂直居中。</p>
<h3 id="absolute与整体布局">absolute与整体布局</h3><h4 id="body降级，子元素升级">body降级，子元素升级</h4><p>升级的子div满屏</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.page</span> &#123;</span><br><span class="line">	<span class="attribute">position</span><span class="value">: absolute;</span></span><br><span class="line">	<span class="attribute">left</span><span class="value">: <span class="number">0</span>;</span></span><br><span class="line">	<span class="attribute">top</span><span class="value">: <span class="number">0</span>;</span></span><br><span class="line">	<span class="attribute">right</span><span class="value">: <span class="number">0</span>;</span></span><br><span class="line">	<span class="attribute">bottom</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绝对定位受限于父级，因此需要</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">html</span>, <span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="各模块－头尾及侧边栏（PC端）各居其位">各模块－头尾及侧边栏（PC端）各居其位</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">header</span>, <span class="tag">footer</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">header</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">48px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">footer</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">52px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">aside</span>(侧边栏) <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="内容区域想象成body">内容区域想象成body</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.content</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">48px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">52px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">300px</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">overflow</span>:<span class="value"> auto</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="全屏覆盖与page平级">全屏覆盖与page平级</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.overlay &#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	top: <span class="number">0</span>;</span><br><span class="line">	left: <span class="number">0</span>;</span><br><span class="line">	right: <span class="number">0</span>;</span><br><span class="line">	bottom: <span class="number">0</span>;</span><br><span class="line">	background-color: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">	z-index: <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"page"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"overlay"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/React服务端渲染/" itemprop="url">
                  React服务端渲染
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-03-18T14:43:39+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>服务端渲染作用</p>
</blockquote>
<ul>
<li>便于SEO，可降低首屏加载时间</li>
</ul>
<blockquote>
<p>服务端渲染原理</p>
</blockquote>
<ul>
<li>service与client共享一部分代码</li>
<li>server拿到首次渲染需要的初始化数据state</li>
<li>server根据state把组件转换为HTML字符串</li>
<li>server把HTML和state发到客户端</li>
</ul>
<p>React提供了renderToString和renderToStaticMarkup两个方法，它们支持将React Component直接输出成HTML字符串。因此，可以在服务端执行React，然后将渲染结果返回。</p>
<h3 id="1_renderToString_&amp;_renderToStaticMarkup">1 renderToString &amp; renderToStaticMarkup</h3><ul>
<li>renderToString</li>
</ul>
<blockquote>
<p>用在服务端，把React Component渲染成HTML，然后通过response发送到浏览器端，达到SEO的目的</p>
</blockquote>
<ul>
<li>renderToStaticMarkup</li>
</ul>
<blockquote>
<p>和renderToString类似，但它生成的HTML中不包含类似data-react-id这样的属性，可用于生成简单的静态页面。</p>
</blockquote>
<p>还需要考虑以下问题：</p>
<ul>
<li><p>初始数据异步请求：所有需要在服务端渲染的数据请求，都需要在返回HTML之前处理完</p>
</li>
<li><p>Action和Store该如何管理？Action事件发送是在数据之前还是之后？</p>
</li>
<li><p>服务端数据需要初始化，浏览器端数据也需要初始化。所以浏览器端需要保存一个副本，该副本如何保存，浏览器端Store如何初始化？</p>
</li>
<li><p>前后端代码共享</p>
</li>
<li><p>前后端路由统一处理</p>
</li>
</ul>
<h3 id="2_服务端渲染与状态共享">2 服务端渲染与状态共享</h3><p>在设计服务端渲染组件时，应考虑如何将state传递到客户端，以便充分利用服务端渲染的优势，同时也要保证同一个props传递到组件中，总会输出相同的渲染结果。</p>
<h4 id="2-1_checksum的失效">2.1 checksum的失效</h4><p>如下组件，在服务端渲染，每次都会输出一个随机数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloComponent = React.createClass(&#123;</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;&#123;Math.random()&#125;&lt;div&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> html = ReactDOMServer.renderToString(&lt;HelloComponent /&gt;);</span><br></pre></td></tr></table></figure>
<p>这个组件会导致data-react-checksum值检测失败，React会抛弃服务端的渲染结果，而在客户端重新进行渲染，这样就失去了服务端渲染的优势。</p>
<h4 id="2-2_解决方案">2.2 解决方案</h4><p>对该组件进行重构，将随机数封装到props中，将props传递到客户端共享状态。</p>
<ul>
<li>重构组件</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloComponent = React.createClass(&#123;</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;&#123;<span class="keyword">this</span>.props.number&#125;&lt;div&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>服务端渲染</li>
</ul>
<p>服务端渲染组件后，除了渲染的HTML传递到页面外，还要将客户端使用的props传递到页面。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = Math.random();</span><br><span class="line"><span class="comment">//server render</span></span><br><span class="line"><span class="keyword">var</span> html = ReactDOMServer.renderToString(&lt;HelloComponent number=&#123;<span class="built_in">num</span>&#125; /&gt;);</span><br><span class="line"><span class="comment">//向页面传递渲染后HTML字符串和num(props)</span></span><br><span class="line">res.render(<span class="string">'random-props'</span>, &#123;html: html, <span class="built_in">num</span>: <span class="built_in">num</span>&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端渲染</li>
</ul>
<p>客户端会在页面加载完成，使用服务端传递的props重新渲染组件，由于前后端的props值相同，React的checksum检测就会通过。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloComponent <span class="keyword">from</span> <span class="string">'./HelloComponent'</span>;</span><br><span class="line"><span class="keyword">var</span> mountNode = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"><span class="comment">//使用服务端传递初始值重新渲染组件</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="title">HelloComponent</span> <span class="attribute">number</span>=<span class="value">&#123;props.num&#125;</span> /&gt;</span>, mountNode);</span></span><br></pre></td></tr></table></figure>
<h3 id="3_服务端使用Redux">3 服务端使用Redux</h3><ul>
<li>Store</li>
</ul>
<blockquote>
<p>整个应用只有一个唯一的Store</p>
<p>Store对应的状态树（state），由reducer函数生成</p>
<p>state树的每个字段都可以进一步由不同的reducer函数生成</p>
<p>Store包含dispatch、getState等方法来处理数据流</p>
<p>Store的state树只能由dispatch(action)来触发更改</p>
</blockquote>
<ul>
<li>redux的数据流</li>
</ul>
<blockquote>
<p>action是一个包含{ type, payload }的对象</p>
<p>reducer函数通过store.dispatch(action)触发</p>
<p>reducer函数接收（state，action）两个参数，返回一个新的state</p>
<p>reducer函数判断action.type，然后处理对应的action.payload数据来更新state树</p>
</blockquote>
<ul>
<li>从服务端把数据发送到客户端，需要以下步骤</li>
</ul>
<blockquote>
<p>为每次请求创建全新的Redux store实例</p>
<p>按需dispatch(action)</p>
<p>从store中获取state</p>
<p>把state一同返回给客户端</p>
</blockquote>
<p>在客户端，使用服务端返回的state创建并初始化一个全新的Redux store。</p>
<p>Redux在服务端唯一要做的事情就是：提供应用所需的初始state。</p>
<h4 id="3-1_服务端">3.1 服务端</h4><p>Redux服务端渲染流程：</p>
<ul>
<li>获取store</li>
<li>获取初始化state</li>
<li>用renderToString注入到模板中，初始化state存到window对象中，在客户端使用window._initial_state获取</li>
<li>发送注入模板后的字符串到客户端</li>
</ul>
<h3 id="4_服务端开发">4 服务端开发</h3><blockquote>
<p>server.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./containers/App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次请求都会触发</span></span><br><span class="line">app.use(handleRender);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderFullPage</span>(<span class="params">html, initialState</span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure>
<h4 id="4-1_处理请求">4.1 处理请求</h4><p>每次请求都创建一个新的Redux store实例，该store的唯一作用是提供应用初始的state。</p>
<p>渲染时，使用<provider>包住根组件<app>，让组件树中所有组件都能访问到store。</app></provider></p>
<p>服务端渲染最关键的一步是在发送响应前渲染初始的HTML，使用renderToString()方法。</p>
<p>然后使用store.getState()从store得到初始state。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//创建新的Redux store实例</span></span><br><span class="line">	<span class="keyword">const</span> store = createStore(rootReducer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把组件渲染成字符串</span></span><br><span class="line">	<span class="keyword">const</span> html = renderToString(</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="title">Provider</span> <span class="attribute">store</span>=<span class="value">&#123;store&#125;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">App</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">Provider</span>&gt;</span></span><br><span class="line">	)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从store中获得初始state</span></span><br><span class="line">	<span class="keyword">const</span> initialState = store.getState();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把渲染后的页面内容发送到客户端</span></span><br><span class="line">	res.send(renderFullPage(html, initialState));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2_注入初始组件的HTML和State">4.2 注入初始组件的HTML和State</h4><p>服务端渲染最后一步是把初始组件的HTML和初始state注入到客户端能够渲染的模板中。</p>
<ul>
<li>如何传递state呢？</li>
</ul>
<blockquote>
<p>添加一个<script>标签，把initialState赋给window._INITIAL<em>STATE</em>，客户端通过window._INITIAL<em>STATE</em>获取initialState。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function renderFullPage(html, initialState) &#123;</span><br><span class="line">	return `</span><br><span class="line">		<span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">title</span>&gt;</span>react server render<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">'container'</span>&gt;</span>$&#123;html&#125;<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">					<span class="built_in">window</span>._INITIAL_STATE_ = $&#123;<span class="built_in">JSON</span>.stringify(initialState)&#125;</span><br><span class="line">				</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">'/build/bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line">	`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6_客户端开发">6 客户端开发</h3><p>客户端只需要从window._INITIAL<em>STATE</em>得到初始state，并传给createStore()函数即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./container/App'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过服务端注入的初始state</span></span><br><span class="line"><span class="keyword">const</span> initialState = <span class="built_in">window</span>._INITIAL_STATE_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用初始state创建Redux store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, initialState);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="title">Provider</span> <span class="attribute">store</span>=<span class="value">&#123;store&#125;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">App</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">Provider</span>&gt;</span>,</span><br><span class="line">	document.querySelector('#container')</span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>
<p>以上就是实现服务端渲染的所有步骤，但也只会用动态代码渲染一个静态view。</p>
<h3 id="7_如何动态创建state渲染动态view？">7 如何动态创建state渲染动态view？</h3><p>客户端只执行收到的代码，刚开始的初始state可能是空的，然后根据需要获取state。在服务端，渲染是同步执行的而且我们只有一次渲染view的机会。在收到请求时，可能需要根据请求参数或者外部state（如API请求或访问数据库），计算后得到初始state。</p>
<h4 id="7-1_处理Request参数">7.1 处理Request参数</h4><p>服务端收到的唯一输入是浏览器的请求。</p>
<blockquote>
<p>server.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//如果存在的话，从request读取参数</span></span><br><span class="line">	<span class="keyword">const</span> params = qs.parse(req.query);</span><br><span class="line">	<span class="keyword">const</span> counter = <span class="built_in">parseInt</span>(params.counter) || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到初始state</span></span><br><span class="line">	<span class="keyword">let</span> initialState = &#123; counter &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建新的Redux store实例</span></span><br><span class="line">	<span class="keyword">const</span> store = createStore(rootReducer, initialState);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把组件渲染成字符串</span></span><br><span class="line">	<span class="keyword">const</span> html = renderToString(</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="title">Provider</span> <span class="attribute">store</span>=<span class="value">&#123;store&#125;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">App</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">Provider</span>&gt;</span></span><br><span class="line">	)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从Redux store得到初始state</span></span><br><span class="line">	<span class="keyword">const</span> finalState = store.getState();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把渲染后的页面发给客户端</span></span><br><span class="line">	res.send(renderFullPage(html, finalState));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2_获取异步state">7.2 获取异步state</h4><p>服务端渲染常用的场景是处理异步state。因为服务端渲染是同步的，如何将异步的数据获取操作对应到同步操作呢？</p>
<p>最简单的做法就向同步代码里面传递一些回调函数。在这个回调函数里引用响应对象，把渲染后的HTML发给客户端。</p>
<h3 id="8_React-router服务端渲染">8 React-router服务端渲染</h3><p>react-router在服务端渲染与客户端有所不同，需要：</p>
<blockquote>
<ul>
<li><p>发送错误时发送一个500响应</p>
</li>
<li><p>需要重定向时发送一个30x响应</p>
</li>
<li><p>在渲染之前获得数据</p>
</li>
</ul>
</blockquote>
<p>为了满足这些需求，需要在<Router> API下一层使用：</p>
<blockquote>
<ul>
<li><p>使用match在渲染之前根据location匹配route</p>
</li>
<li><p>使用RoutingContext同步渲染route组件</p>
</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; match, RoutingContext &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> routers <span class="keyword">from</span> <span class="string">'./routes'</span>;</span><br><span class="line"></span><br><span class="line">app.use( (req, res) =&gt; &#123;</span><br><span class="line">	match(&#123; routes, location: req.url &#125;, (error, redirectLocation, renderProps) =&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span>(error) &#123;</span><br><span class="line">			res.send(<span class="number">500</span>, error.message);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(redirectLocation) &#123;</span><br><span class="line">			res.redirect(<span class="number">302</span>, redirectLocation.pathname + redirectLocation.search);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderProps) &#123;</span><br><span class="line">			res.send(<span class="number">200</span>, renderToString(</span><br><span class="line">				<span class="xml"><span class="tag">&lt;<span class="title">RoutingContext</span> &#123;<span class="attribute">...renderProps</span>&#125; /&gt;</span></span><br><span class="line">			)</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			res.send(<span class="number">404</span>, <span class="string">'Not Found'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</script></p></blockquote>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/Redux数据流/" itemprop="url">
                  Redux数据流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-03-18T10:19:11+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>严格的单向数据流是Redux架构的设计核心。</p>
<p>应该中所有的数据都遵循相同的生命周期。</p>
<p>Redux应用中数据的生命周期遵循下面4个步骤：</p>
<h3 id="1_调用store-dispatch(action)">1 调用store.dispatch(action)</h3><p>action就是一个描述发生了什么的普通对象，如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">type</span>:<span class="value"> <span class="string">'update'</span>,</span><br><span class="line">	index: <span class="number">12</span></span><br><span class="line"></span></span></span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2_Redux_store调用传入的reducer函数">2 Redux store调用传入的reducer函数</h3><p>store会给reducer传入两个参数：当前的state树和action。</p>
<p>reducer是纯函数，仅仅用于计算下一个state，它的行为应该是完全可预测的：多次传入相同的输入必定产生相同的输出。</p>
<h3 id="3_根reducer应该把多个子reducer输出合并成一个单一的state树">3 根reducer应该把多个子reducer输出合并成一个单一的state树</h3><p>根reducer的结构完全由我们决定。Redux原生提供了combinerReducers()辅助函数，用来把各个子reducer合并成一个reducer，输出一个单一的state树。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span><span class="params">(state = [], action)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibleTodoFilter</span><span class="params">(state = <span class="string">'SHOW_ALL'</span>, action)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> nextState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> todoApp = combineReducers(&#123;</span><br><span class="line">	todos,</span><br><span class="line">	visibleTodoFilter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="4_Redux_store保存了根reducer返回的完整state树">4 Redux store保存了根reducer返回的完整state树</h3><p>返回的新的state树就是应用的下一个state。所有订阅store.subscribe(listener)的监听器都将被调用；在监听器里调用store.getState()获得当前state。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/middleware演变过程/" itemprop="url">
                  middleware演变过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-03-18T10:15:18+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过记录日志来说明Middleware的演变过程。</p>
<blockquote>
<p>当应用中每一个action被发起以及每次新的state被计算完成时都将它们记录下来，如何通过Redux实现？</p>
</blockquote>
<h3 id="1_手动记录">1 手动记录</h3><p>最直接的方法是每次调用store.dispatch(action)前后手动记录被发起的action和state。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="function"><span class="title">dispatch</span><span class="params">(addTodo(<span class="string">'Redux'</span>)</span></span>)</span><br></pre></td></tr></table></figure>
<p>为了记录这个action及产生的新的state，可以通过以下方式记录日志。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let action = addTodo('Redux');</span><br><span class="line"></span><br><span class="line">console.<span class="keyword">log</span>('dispatching action:' , action);</span><br><span class="line">store.dispatch(action);</span><br><span class="line">console.<span class="keyword">log</span>('next <span class="keyword">state</span>:', store.getState());</span><br></pre></td></tr></table></figure>
<h3 id="2_封装Dispatch">2 封装Dispatch</h3><p>可以将上面的操作封装成一个函数。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> dispatchAndLog(store, <span class="keyword">action</span>) &#123;</span><br><span class="line">	console.<span class="built_in">log</span>(<span class="string">'dispatching action:'</span>, <span class="keyword">action</span>);</span><br><span class="line">	store.dispatch(<span class="keyword">action</span>);</span><br><span class="line">	console.<span class="built_in">log</span>(<span class="string">'next state:'</span>, store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用dispatchAndLog方法替换store.dispatch()。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatchAndLog<span class="list">(<span class="keyword">store</span>, addTodo<span class="list">(<span class="quoted">'Redux</span>')</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="3_Moneypatching_Dispatch">3 Moneypatching Dispatch</h3><p>如果我们直接替换store实例中dispatch函数会怎么样呢？</p>
<p>Redux store只是一个包含一些方法的普通对象，因此我们可以这样实现dispatch的monkeypatch。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">store.dispatch = function dispatchAndLog(action) &#123;</span><br><span class="line">	console.log('dispatching action:', action);</span><br><span class="line">	<span class="keyword">let</span> <span class="literal">result</span> = next(action);</span><br><span class="line">	console.log('next state:', store.getState());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，无论我们从哪里发起action，保证都会被记录。此时，如果我们想对dispatch附加超过一个的变换时会怎么样？如记录JS报错信息，而这和日志记录应该属于不同的模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchStoreAddLog</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">	store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'dispatching action:'</span>, action);</span><br><span class="line">		<span class="keyword">let</span> result = next(action);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'next state:'</span>, store.getState());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchStoreAddReporting</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">	store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndReporting</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> next(action);</span><br><span class="line">		&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">			<span class="built_in">console</span>.error(<span class="string">'has a error:'</span>, err);</span><br><span class="line">			Raven.captureException(err, &#123;</span><br><span class="line">				extra: &#123;</span><br><span class="line">					action,</span><br><span class="line">					state: store.getState()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">throw</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在store中就可以使用它们：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchStoreAddLog<span class="list">(<span class="keyword">store</span>)</span><span class="comment">;</span></span><br><span class="line">patchStoreAddReporting<span class="list">(<span class="keyword">store</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="4_隐藏Moneypatching">4 隐藏Moneypatching</h3><p>Moneypatching本质上是一种hack：将任意的方法替换成我们需要的。我们使用自己的函数替换了store.dispatch，如果我们不这样做，而是在函数中返回新的dispatch，会怎么样呢？</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function logger(store) &#123;</span><br><span class="line">	<span class="keyword">let</span> next = store.dispatch;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> function dispatchAndLog(action) &#123;</span><br><span class="line">		console.log('dispatching action:', action);</span><br><span class="line">		<span class="keyword">let</span> <span class="literal">result</span> = next(action);</span><br><span class="line">		console.log('next state:', store.getState());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在Redux内部提供一个可以将实际的monkeypatching应用到store.dispatch中的辅助方法。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddlewareByMonkeypatching</span><span class="params">(store, middlewares)</span> </span>&#123;</span><br><span class="line">	middlewares = middlewares.slice();</span><br><span class="line">	middlewares.reverse();</span><br><span class="line"></span><br><span class="line">	middlewares.<span class="keyword">forEach</span>(middleware =&gt;</span><br><span class="line">		store.dispatch = middleware(store)</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以应用多个middleware。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">applyMiddlewareByMonkeypatching</span><span class="params">(store, [logger, reporting])</span></span></span><br></pre></td></tr></table></figure>
<p>尽管我们做了很多，但实现方式依然是monkeypatching。</p>
<h3 id="5_移除Monkeypatching">5 移除Monkeypatching</h3><p>为什么要替换原来的dispatch呢？</p>
<blockquote>
<p>可以在后面直接调用它</p>
<p>每一个middleware都可以操作或直接调用前一个middleware包装过的store.dispatch</p>
</blockquote>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function logger(store) &#123;</span><br><span class="line">	//这里的next必须指向前一个middleware返回的函数</span><br><span class="line">	<span class="keyword">let</span> next = store.dispatch;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> function dispatchAndLog(action) &#123;</span><br><span class="line">		console.log('dispatching action:', action);</span><br><span class="line">		<span class="keyword">let</span> <span class="literal">result</span> = next(action);</span><br><span class="line">		console.log('next state:', store.getState());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将middleware串起来是非常有必要的。如果applyMiddlewareByMonkeypatching方法中没有在第一个middleware执行时立即替换掉store.dispatch，那么store.dispatch将会一直指向原始的dispatch方法。即第二个middleware依旧会作用在原始的dispatch方法上。</p>
<p>还有另外一种实现这种链式调用的效果：让middleware以方法参数的形式接收一个next()方法，而不是通过store的实例去获取。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function logger(store) &#123;</span><br><span class="line">	<span class="keyword">return</span> function wrapDispatchAddLogge(next) &#123;</span><br><span class="line">		<span class="keyword">return</span> function dispatchAndLog(action) &#123;</span><br><span class="line">			console.log('dispatching action:', action);</span><br><span class="line">			<span class="keyword">let</span> <span class="literal">result</span> = next(action);</span><br><span class="line">			console.log('next state:', store.getState());</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ES6的箭头函数使其柯里化。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">	console.log('dispatching action:', action);</span><br><span class="line">	<span class="keyword">let</span> <span class="literal">result</span> = next(action);</span><br><span class="line">	console.log('next state:', store.getState());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reporting = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> next(action)</span><br><span class="line">	&#125; catch(err) &#123;</span><br><span class="line">		console.log('has a error:', err);</span><br><span class="line">		<span class="type">Raven</span>.captureException(err, &#123;</span><br><span class="line">			extra: &#123;</span><br><span class="line">				action,</span><br><span class="line">				state: store.getState()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		throw err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这正是Redux middleware的样子。</p>
<p>Middleware接收一个next()的dispatch函数，并返回一个dispatch函数，返回的函数被作为下一个middleware的next()，以此类推。由于store中类似getState()方法非常有用，因此我们将store作为顶层的参数，使得它可以在所有middleware中被使用。</p>
<h3 id="6_“单纯”地使用Middleware">6 “单纯”地使用Middleware</h3><p>写一个applyMiddleware()方法替换原来的applyMiddlewareByMonkeypatching()。在applyMiddleware()方法中，获取到完整的被包装过的dispatch()函数，并返回一个store的副本。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span><span class="params">(store, middlewares)</span> </span>&#123;</span><br><span class="line">	middlewares = middlewares.slice();</span><br><span class="line">	middlewares.reverse();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> dispatch = store.dispatch;</span><br><span class="line">	middlewares.<span class="keyword">forEach</span>( middleware =&gt;</span><br><span class="line">		dispatch = middleware(store)(dispatch)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Object.assign(&#123;&#125;, store, &#123; dispatch &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码与Redux中applyMiddleware()的实现已经很接近了，但有三个重要的不同之处：</p>
<blockquote>
<ul>
<li><p>它只暴露一个store API的子集给middleware：dispatch(action)和getState()</p>
</li>
<li><p>它用了一个非常巧妙的方式来保证middleware调用的是store.dispatch(action)而不是next(action)，从而使这个action会在包括当前middleware在内的整个middleware链中被正确的传递。</p>
</li>
<li><p>为了保证只应用middleware一次，它作用在createStore()上而不是store本身。因此它的签名不是(store, middlewares) =&gt; store，而是(…middlewares) =&gt; (createStore) =&gt; createStore</p>
</li>
</ul>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/29/翻译-React组件、元素和实例/" itemprop="url">
                  [翻译]React组件、元素和实例
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-29T15:14:42+08:00" content="2016-01-29">
              2016-01-29
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>组件、组件实例和元素之间的区别会让很多初学者感到困惑。为什么会有三种不同的术语来指代渲染到屏幕上的东西呢？</p>
<h3 id="管理实例">管理实例</h3><p>如果你是React初学者，你可能只会用到组件类和它的实例。例如，你可以通过创建一个类来声明一个Button组件。当应用程序运行的时候，可能会有这个组件的多个实例，每一个都有自己的属性和本地状态。这就是传统的面向对象的GUI编程，为什么要引入元素？</p>
<p>在这个传统的UI模型中，你需要关心子组件实例的创建和销毁。如果一个Form组件要渲染一个Button组件，需要创建它的实例，并且需要手动更新它的状态。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">TraditionalObjectOrientedView</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		const &#123; isSubmitted, buttonText &#125; = <span class="keyword">this</span>.attrs;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!isSubmitted &amp;&amp; !<span class="keyword">this</span>.button) &#123;</span><br><span class="line">			<span class="comment">//form还没有提交，创建Button实例</span></span><br><span class="line">			<span class="keyword">this</span>.button = <span class="keyword">new</span> <span class="type">Button</span>(&#123;</span><br><span class="line">				children: buttonText,</span><br><span class="line">				color: <span class="symbol">'blu</span>e'</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">this</span>.el.appendChild(<span class="keyword">this</span>.button.el);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.button) &#123;</span><br><span class="line">			<span class="comment">//button是可用的，更新文本信息</span></span><br><span class="line">			<span class="keyword">this</span>.button.attrs.children = buttonText;</span><br><span class="line">			<span class="keyword">this</span>.button.render();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(isSubmitted &amp;&amp; <span class="keyword">this</span>.button) &#123;</span><br><span class="line">			<span class="comment">//表单已提交，销毁button组件实例</span></span><br><span class="line">			<span class="keyword">this</span>.el.removeChild(<span class="keyword">this</span>.button.el);</span><br><span class="line">			<span class="keyword">this</span>.button.destory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(isSubmmited &amp;&amp; !<span class="keyword">this</span>.message) &#123;</span><br><span class="line">			<span class="comment">//表单提交成功，显示提示信息</span></span><br><span class="line">			<span class="keyword">this</span>.message = <span class="keyword">new</span> <span class="type">Message</span>(&#123;text: <span class="symbol">'succes</span>s'&#125;);</span><br><span class="line">			<span class="keyword">this</span>.el.appendChild(<span class="keyword">this</span>.message.el);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是伪代码，当你使用比如Backbone这种传统的面向对象的库开发复合UI代码时，最终或多或少有这种体验。</p>
<p>每个组件实例都要保持对DOM节点和子组件实例的引用，在适合的时间创建，更新并销毁。</p>
<p>随着代码量的增加，组件可能的状态数会按平方级增长，并且父级可以直接访问子组件的实例，将来想要解偶就会变的非常困难。</p>
<p>那么，React有何不同呢？</p>
<h3 id="用元素来描述树形结构">用元素来描述树形结构</h3><p>在React里面，使用元素来解决这种问题。<strong>一个元素就是一个普通的对象，用来描述组件实例或DOM节点或它所需的属性</strong>。它只包括组件类型（如Button）、组件属性及组件的所有子元素的信息。</p>
<p>元素不是一个真实的实例。相反，它是告诉React在屏幕上展示哪些内容的一种方式。不能在元素上调用任何方法。它只是一个不可变的描述性的对象，拥有两个字段：type（string或ReactClass）和props（object）。</p>
<h4 id="DOM元素">DOM元素</h4><p>当一个元素的类型是字符串，它表示该标签名对应的DOM节点，props对应它的属性。这就是React怎么渲染的。如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">type</span>:<span class="value"> <span class="string">'button'</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		className: <span class="string">'button button-blue'</span>,</span><br><span class="line">		children: &#123;</span><br><span class="line">			type: <span class="string">'b'</span>,</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: <span class="string">'OK!'</span></span><br><span class="line">			</span></span></span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个也只是用普通对象表示下面HTML的一种方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">'button button-blue'</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">b</span>&gt;</span></span><br><span class="line">		OK!</span><br><span class="line">	<span class="tag">&lt;/<span class="title">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意元素如何嵌套。按照惯例，当我们想创建一个元素树的时候，我们指定一个或多个子元素，作为它们包含元素的子属性。</p>
<p>重要的是都是描述子元素和父元素，而不是真实的实例。当创建它们的时候不参考屏幕上面的任何东西。你可以创建它们，也可以丢弃掉，都不会有太大的影响。</p>
<p>React元素很容易遍历，不需要进行解析，相对于实际DOM元素它们很轻量，它们只是对象而已。</p>
<h4 id="组件元素">组件元素</h4><p>元素的类型可以是函数或对应于React组件的类。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">type</span>:<span class="value"> Button,</span><br><span class="line">	props: &#123;</span><br><span class="line">		color: <span class="string">'blue'</span>,</span><br><span class="line">		children: <span class="string">'OK!'</span></span><br><span class="line">	</span></span></span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是React的核心理念。</p>
<p><strong>描述组件的元素也是一个元素，就像描述DOM节点的元素。它们可以彼此嵌套和混合。</strong></p>
<p>这个特性可以让你使用具有特定的颜色属性值的Button定义一个DangerButton组件，而完全不用担心Button组件渲染到DOM中以后是button、div或别的其它什么东西。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const DangerButton = <span class="function"><span class="params">(&#123; children &#125;)</span> =&gt;</span> (&#123;</span><br><span class="line">	<span class="attribute">type</span>: Button,</span><br><span class="line">	<span class="attribute">props</span>: &#123;</span><br><span class="line">		<span class="attribute">color</span>: <span class="string">'red'</span>,</span><br><span class="line">		<span class="attribute">children</span>: children</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一个元素树形结构中可以混合和匹配DOM元素和组件元素。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const DeleteAccount = () =&gt; (&#123;</span><br><span class="line">	type: <span class="string">'div'</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		children: [&#123;</span><br><span class="line">			type: <span class="string">'p'</span>,</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: <span class="string">'Are you sure?'</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			type: DangerButton,</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: <span class="string">'Yep'</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			type: Button,</span><br><span class="line">			props: &#123;</span><br><span class="line">				color: <span class="string">'blue'</span>,</span><br><span class="line">				children: <span class="string">'Cancel'</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用JSX表示形式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const DeleteAccount = () =&gt; (</span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">p</span>&gt;</span>Are you sure?<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">DangerButton</span>&gt;</span>Yep<span class="tag">&lt;/<span class="title">DangerButton</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">Button</span> <span class="attribute">color</span>=<span class="value">'blue'</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="title">Button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这种混合和匹配有助于降低组件之间的耦合度，因此它们完全可以通过一下的结构同时表达is-a和has-a的关系：</p>
<blockquote>
<ul>
<li>Button组件是一个具有特定属性的DOM元素button；</li>
<li>DangerButton组件是一个具有特定属性的Button组件；</li>
<li>DeleteAccount在一个div元素中包含一个Button组件和一个DangerButton组件。</li>
</ul>
</blockquote>
<h3 id="组件封装元素树">组件封装元素树</h3><p>当React看到一个有function或class类型的元素时，它就会询问这个组件会渲染出什么元素，并提供了哪些对应的props。</p>
<p>当React看到下面这个元素时：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">type</span>:<span class="value"> Button,</span><br><span class="line">	props: &#123;</span><br><span class="line">		color: <span class="string">'blue'</span>,</span><br><span class="line">		children: <span class="string">'OK!'</span></span><br><span class="line">	</span></span></span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React将会问Button组件会渲染出什么，这个Button组件将会返回以下元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">type</span>:<span class="value"> <span class="string">'button'</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		className: <span class="string">'button button-blue'</span>,</span><br><span class="line">		children: &#123;</span><br><span class="line">			type: <span class="string">'b'</span>,</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: <span class="string">'OK!'</span></span><br><span class="line">			</span></span></span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React将会重复这个过程，直到页面上所有的组件都被替换为底层DOM标签元素为止。</p>
<p>React就像一个小孩，每遇到一个“X is Y”就会问“什么是Y”，你就需要给他解释，直到他弄清楚了所有的事情。</p>
<p>还记得上面的Form栗子吗？使用React可以写成如下形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const <span class="type">Form</span> = (&#123; isSubmmited buttonText &#125;) =&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span>(isSubmitted) &#123;</span><br><span class="line">		<span class="comment">//Form已经提交，返回一个message元素</span></span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span>:</span> <span class="type">Message</span>,</span><br><span class="line">			props: &#123;</span><br><span class="line">				text: <span class="symbol">'Success</span>!'</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//form仍然可用，返回一个button元素</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">type</span>:</span> <span class="type">Button</span>,</span><br><span class="line">		props: &#123;</span><br><span class="line">			children: buttonText,</span><br><span class="line">			color: <span class="symbol">'blu</span>e'</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经此而已！对于一个React组件，props是输入，输出是元素树。</p>
<p><strong>返回的元素树包括描述DOM节点的元素及描述其它组件的元素。这可以让我们独立地编写UI部分，而无需依赖它们的内部DOM结构。</strong></p>
<p>我们可以创建、更新和销毁React实例。我们使用返回的组件元素描述它们，React只关心实例的管理。</p>
<h3 id="组件可以是Classes或Functions">组件可以是Classes或Functions</h3><p>在上面的代码中，Form、Message和Button都是React组件。它们既可以使用函数方式来写，就像上面的代码，也可以使用继承了React.Component的classes。以下三种声明组件的方式大都是等价的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 作为props的函数</span></span><br><span class="line">const <span class="type">Button</span> = (&#123; children, color &#125;) =&gt; (&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span>:</span> <span class="symbol">'butto</span>n',</span><br><span class="line">	props: &#123;</span><br><span class="line">		className: <span class="symbol">'button</span> button-' + color,</span><br><span class="line">		children: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span>:</span> 'b',</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: children</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 使用React.createClass()工厂方法</span></span><br><span class="line">const <span class="type">Button</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">	render: function() &#123;</span><br><span class="line">		const &#123; children, color &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span>:</span> <span class="symbol">'butto</span>n',</span><br><span class="line">			props: &#123;</span><br><span class="line">				className: <span class="symbol">'button</span> button-' + color,</span><br><span class="line">				children: &#123;</span><br><span class="line">					<span class="class"><span class="keyword">type</span>:</span> 'b',</span><br><span class="line">					props: &#123;</span><br><span class="line">						children: children</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 使用继承了React.Component的ES6类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		const &#123; children, color &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span>:</span> <span class="symbol">'butto</span>n',</span><br><span class="line">			props: &#123;</span><br><span class="line">				className: <span class="symbol">'button</span> button-' + color,</span><br><span class="line">				children: &#123;</span><br><span class="line">					<span class="class"><span class="keyword">type</span>:</span> 'b',</span><br><span class="line">					props: &#123;</span><br><span class="line">						children: children</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个组件使用class来定义时，它的功能比使用function定义的组件要强大一点。当对应的DOM节点被创建或销毁时它可以存储一些局部变量并执行自定义逻辑。</p>
<p>函数组件功能没有那么强大，但它比较简单，类似于只有一个单一的render()方法的类组件。除非在class中需要提供其它的功能，否则推荐使用函数组件。</p>
<p><strong>然而，无论是函数组件或类组件，本质上都是React组件。它们把props作为其输入，并返回元素作为它们的输出。</strong></p>
<h3 id="自上而下的协同">自上而下的协同</h3><p>当你调用如下代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ReactDOM</span><span class="class">.render</span>(&#123;</span><br><span class="line">	<span class="tag">type</span>: <span class="tag">Form</span>,</span><br><span class="line">	<span class="tag">props</span>: &#123;</span><br><span class="line">		<span class="attribute">isSubmitted</span>: false,</span><br><span class="line">		<span class="attribute">buttonText</span>: <span class="string">'OK!'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;, document.<span class="function">getElementById</span>(<span class="string">'container'</span>));</span><br></pre></td></tr></table></figure>
<p>React会问这个Form组件返回什么样的元素树及其提高的props。React将会根据在简单的原语层面对React组件的理解来逐步完善它。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//React: You told me this...</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span>:</span> <span class="type">Form</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		isSubmitted: <span class="literal">false</span>,</span><br><span class="line">		buttonText: <span class="symbol">'OK</span>!'</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//React: Form提供的信息</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span>:</span> <span class="type">Button</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		children: <span class="symbol">'OK</span>!',</span><br><span class="line">		color: <span class="symbol">'blu</span>e'</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//React: Button提供的信息</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span>:</span> <span class="symbol">'butto</span>n',</span><br><span class="line">	props: &#123;</span><br><span class="line">		className: <span class="symbol">'button</span> button-blue',</span><br><span class="line">		children: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span>:</span> 'b',</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: <span class="symbol">'OK</span>!'</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用ReactDOM.render()或setState()时，这就是被React成为协同的过程。协同的过程结束以后，React已经知道了DOM树的结果，react-dom或react-native根据需要更新的DOM节点进行一次最小的渲染。</p>
<p>这种渐进精炼的过程也是React应用很容易优化的原因。如果组件树的一部分变的太大而不能高效的访问，如果想过的props并没有改变时，你可以告诉React跳过这个“refining”和比较组件树的某些部分的过程。如果它们是不可变的，则计算props是否改变了就会非常快，因此React和不可变的数据能够很好的工作，并且很小的工作量就可以起到极大的优化作用。</p>
<p>你可能已经注意到了，这篇博客谈了很多有关组件和元素的内容，并没有过多的谈论实例。事实就是，在React中，实例并没有在大多数面对对象的UI框架中那么重要。</p>
<p>仅仅使用class来声明组件，就会有实例，从来不需要直接创建它们：React已经替我们创建了实例。存在一个父组件实例访问子组件实例的机制，它们仅被用于一些不得已的操作（如设置字段焦点），通常应该避免这样的操作。</p>
<p>React需要为每一个class组件创建实例，因此你可以使用面对对象的方式，使用方法和局部变量来开发组件，但除此之外，实例在React编程模式中不是很重要，并且都是React自身来管理实例的。</p>
<h3 id="总结">总结</h3><p>元素就是普通的对象，用来描述呈现在屏幕上的DOM节点或其它组件。元素的props中可以包含其它元素。创建React元素是廉价的，一旦创建了React元素，就不会再发生变化。</p>
<p>一个组件可以使用几种不同的方式来声明。它可以是一个有render()方法的类。同样地，在一些简单的情况下，它可以被定义为函数。在这两种情况下，它把props作为输入，返回的元素树作为输出。</p>
<p>当一个组件接收到一些props作为输入，这是因为特定的父组件返回了一个具有类型和props的元素。这也就是为什么人们常说的props在React中是单向流动的：从父组件到子组件。</p>
<p>实例就是对组件类中this的引用。</p>
<p>函数组件根本就没有实例。类组件有实例，但永远不需要直接创建组件实例，React会完成这个实例的创建。</p>
<p>最后，要创建元素，可以使用React.createClass()，JSX或元素工厂助手。在真实开发时候不要使用普通对象来创建元素，只需要知道在引擎底层它们是普通对象即可。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="baizn" />
          <p class="site-author-name" itemprop="name">baizn</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">45</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">93</span>
                <span class="site-state-item-name">標籤</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">baizn</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
