<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="baizn的github博客">
<meta property="og:url" content="http://baizn.github.io/index.html">
<meta property="og:site_name" content="baizn的github博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="baizn的github博客">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://baizn.github.io/"/>

  <title> baizn的github博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">baizn的github博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/14/Three-js纹理/" itemprop="url">
                  Three.js纹理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-14T10:41:46+08:00" content="2017-02-14">
              2017-02-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>纹理之于3D世界，就像皮肤之于动物世界一样。</p>
<h3 id="纹理由图片组成">纹理由图片组成</h3><p>Three.js中，纹理是怎么实现的呢？</p>
<p>首先应该有一个纹理类，其次有一个加载图片的方法，这这张图片与这个纹理类绑定起来。</p>
<p>three.js中，纹理类由THREE.Texture表示，构造方法如下：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.Texture(<span class="built_in">image</span>, mapping, wrapS, wrapT, magFilter, minFilter, <span class="built_in">format</span>, <span class="built_in">type</span>, anisotropy)</span><br></pre></td></tr></table></figure>
<p>各参数含义：</p>
<ul>
<li><p>image：图片类型，使用ImageUtils来加载，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> image = THREE<span class="class">.ImageUtils</span><span class="class">.loadTexture</span>(url) <span class="comment">//url是类似http://<span class="label">xxx.com/xx.jpg的地址</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mapping：THREE.UVMapping()类型，表示纹理坐标</p>
</li>
<li><p>wrapS：表示x轴的纹理回环方式，就是当纹理的宽度小于需要贴图的平面的宽度时候，平面剩下的部分应该以何种方式贴图的问题</p>
</li>
<li><p>wrapT：表示y轴纹理回环方式</p>
</li>
<li><p>magFilter/minFilter：表示过滤的方式</p>
</li>
<li><p>format：表示加载图片的格式，取值可以为THREE.RGBAFormat，RGBFormat等</p>
</li>
<li><p>type：表示存储纹理的内存的每一个字节的格式，默认是无符号型</p>
</li>
<li><p>anisotropy：各向异性过滤，使用各向异性过滤能够使纹理效果更好，但会消耗更多的内存、CPU等</p>
</li>
</ul>
<h3 id="纹理坐标">纹理坐标</h3><p>正常情况下，在0.0到1.0的范围内指定纹理坐标。</p>
<p>代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> camera, scene, renderer, mesh</span><br><span class="line">init()</span><br><span class="line">animate()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer = <span class="keyword">new</span> THREE.WebGLRenderer()</span><br><span class="line">  renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>,innerHeight)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(renderer.domElement)</span><br><span class="line"></span><br><span class="line">  camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">70</span>, <span class="built_in">window</span>.innerWidth/<span class="built_in">window</span>.innerHeight, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">  camera.position.z = <span class="number">400</span></span><br><span class="line">  scene = <span class="keyword">new</span> THREE.Scene()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlancGeometry(<span class="number">500</span>, <span class="number">300</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">  geometry.vertices[<span class="number">0</span>].uv = <span class="keyword">new</span> THREE.Vector2(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  geometry.vertices[<span class="number">1</span>].uv = <span class="keyword">new</span> THREE.Vector2(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">  geometry.vertices[<span class="number">2</span>].uv = <span class="keyword">new</span> THREE.Vector2(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">  geometry.vertices[<span class="number">3</span>].uv = <span class="keyword">new</span> THREE.Vector2(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.ImageUtils.loadTexture(<span class="string">'textures/a.jpg'</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    map: texture</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material)</span><br><span class="line">  scene.add(mesh)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, onWindowResize, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onWindowResize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  camera.aspect = <span class="built_in">window</span>.innerWidth/<span class="built_in">window</span>.innerHeight</span><br><span class="line">  camera.updaetProjectionMatrix()</span><br><span class="line">  renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(animate)</span><br><span class="line">  renderer.render(scene, camera)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，总完成了4件事情：</p>
<ul>
<li>画一个平面</li>
<li>为平面赋予纹理坐标</li>
<li>加载纹理</li>
<li>将纹理应用于材质</li>
</ul>
<h4 id="画一个平面">画一个平面</h4><p>通过PlaneGemotry可以画一个平面，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">500</span>, <span class="number">300</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这个平面的宽度是500， 高度是300。</p>
<h4 id="为平面赋予纹理坐标">为平面赋予纹理坐标</h4><p>平面有4个顶点，所有只需指定4个纹理坐标就行。纹理坐标由顶点的uv成员来表示，uv被定义为一个二维向量THREE.Vector2()，可以通过如下代码来为平面定义纹理：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">geometry<span class="class">.vertices</span>[<span class="number">0</span>]<span class="class">.uv</span> = new THREE.<span class="function"><span class="title">Vector2</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span></span><br><span class="line">geometry<span class="class">.vertices</span>[<span class="number">1</span>]<span class="class">.uv</span> = new THREE.<span class="function"><span class="title">Vector2</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span></span><br><span class="line">geometry<span class="class">.vertices</span>[<span class="number">2</span>]<span class="class">.uv</span> = new THREE.<span class="function"><span class="title">Vector2</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span></span><br><span class="line">geometry<span class="class">.vertices</span>[<span class="number">3</span>]<span class="class">.uv</span> = new THREE.<span class="function"><span class="title">Vector2</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="加载纹理">加载纹理</h4><p>加载纹理使用loadTexture函数，如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> texture = THREE.ImageUtils.loadTexture(<span class="string">'textures/a.jpg'</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span><span class="params">(t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>该函数第一个参数表示纹理图片的路径；第二个参数是null，表示需要传入一个纹理坐标参数，来覆盖前面在geometry中的参数；第三个参数是一个回调函数，表示成功加载纹理后需要执行的函数。该函数返回值是加载的纹理。</p>
<h4 id="将纹理应用于材质">将纹理应用于材质</h4><p>加载好纹理后，只需将纹理映射到材质就可以了。使用普通材质THREE.MeshBasicMaterial，材质有一个map属性，可以直接接收纹理，定义带纹理的材质代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="built_in">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  <span class="keyword">map</span>: texture</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>接下来将纹理传给Mesh，同时也需要geometry，如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> mesh = new THREE.<span class="function"><span class="title">Mesh</span><span class="params">(geometry, material)</span></span></span><br><span class="line">scene.<span class="function"><span class="title">add</span><span class="params">(mesh)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="纹理原理">纹理原理</h3><p>从本质上讲，纹理只是图片，它是由像素点组成。无论内存还是显存中，它都是由4个分量组成，这四个分量是R，G，B，和A。唯一不同的是，在显存中，会比内存中更快的渲染到显示器上，因为显存中的帧缓冲本来就是和显示器上的像素一一对应的。</p>
<h3 id="canvas作为纹理">canvas作为纹理</h3><h4 id="将canvas传递给THREE-Texture纹理">将canvas传递给THREE.Texture纹理</h4><p>canvas可以作为纹理传递给THREE.Texture函数，纹理的构造函数是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE<span class="class">.Texture</span> = <span class="function"><span class="title">function</span><span class="params">(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数第一个参数接收一个image类型的图像，或canvas。</p>
<p>只需将canvas传给Texture即可。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">texture = new THREE.<span class="function"><span class="title">Texture</span><span class="params">(canvas)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="将纹理传递给THREE-MeshBasicMaterial材质">将纹理传递给THREE.MeshBasicMaterial材质</h4><p>将texture传递给材质，材质本身接受一个属性名为map的参数，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> materila = <span class="built_in">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  <span class="keyword">map</span>: texture</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="构造THREE-Mesh">构造THREE.Mesh</h4><p>Mesh就是一个网格表面，代表着渲染到3D世界中的各种模型，构造函数如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE<span class="class">.Mesh</span> = <span class="function"><span class="title">function</span><span class="params">(geometry, material)</span></span></span><br></pre></td></tr></table></figure>
<p>接受两个参数，一个是几何体，一个是材质。</p>
<p>使用示例：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> mesh = new THREE.<span class="function"><span class="title">Mesh</span><span class="params">(geometry, material)</span></span></span><br></pre></td></tr></table></figure>
<p>其中geometry是一个THREE.CubeGeometry表示的正方体。</p>
<h3 id="总结">总结</h3><p>核心代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer = <span class="keyword">new</span> THREE.WebGLRenderer()</span><br><span class="line">  renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(renderer.domElement)</span><br><span class="line"></span><br><span class="line">  camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">70</span>, <span class="built_in">window</span>.innerWidth/<span class="built_in">window</span>.innerHeight, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">  camera.position.z = <span class="number">400</span></span><br><span class="line">  scene = <span class="keyword">new</span> THREE.Scene()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CubeGeometry(<span class="number">150</span>, <span class="number">150</span>, <span class="number">150</span>)</span><br><span class="line">  texture = <span class="keyword">new</span> THREE.Texture(canvas)</span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    map: texture</span><br><span class="line">  &#125;)</span><br><span class="line">  texture.needsUpdate = <span class="literal">true</span></span><br><span class="line">  mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material)</span><br><span class="line">  scene.add(mesh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义了纹理之后，需要将texture.needsUpdate设置为true，如果不设置为true，那么纹理就不会更新。纹理的绘制是需要一段时间的，JavaScript是异步运行的，在canvas绘制出时钟之前，可能three.js就开始根据纹理渲染图形了。如果纹理不更新，那么正方体一直会是以前没有绘制完成的纹理，很可能是材质本身的颜色。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/08/Three-js中的光源/" itemprop="url">
                  Three.js中的光源
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-08T21:15:44+08:00" content="2017-02-08">
              2017-02-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="光源的基类">光源的基类</h3><p>Three.js中，光源用Light表示，它是所有光源的基类。构造函数是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.<span class="function"><span class="title">Light</span><span class="params">(hex)</span></span></span><br></pre></td></tr></table></figure>
<p>参数hex：接受一个16进制的颜色值。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> redLight = new THREE.<span class="function"><span class="title">Light</span><span class="params">(<span class="number">0</span>xFF0000)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="其他种类光源">其他种类光源</h3><p>THREE.Light只是其他所有光源的基类，其他光源都继承它。</p>
<ul>
<li>环境光：THREE.AmbientLight</li>
<li>区域光：THREE.AreaLight</li>
<li>方向光：THREE.DirectionalLight</li>
<li>聚光等：THREE.SpotLight</li>
<li>点光源：THREE.PointLight</li>
</ul>
<h3 id="环境光">环境光</h3><p>环境光是经过多次反射而来的光，无法确定其最初的方向。环境光源放出的光线被认为来自任何方向，因此，当仅为场景指定环境光时，所有的物体无论法向量如何，都将表现为同样的明暗程度。</p>
<p>环境光的构造函数如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.<span class="function"><span class="title">AmbientLight</span><span class="params">(hex)</span></span></span><br></pre></td></tr></table></figure>
<p>环境光的使用如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> light = new THREE.<span class="function"><span class="title">AmbientLight</span><span class="params">(<span class="number">0</span>xff0000)</span></span></span><br><span class="line">scene.<span class="function"><span class="title">add</span><span class="params">(light)</span></span></span><br></pre></td></tr></table></figure>
<p>只需要将光源加入场景，场景就能够通过光源渲染出好的效果来了。</p>
<h3 id="点光源">点光源</h3><p>点光源放出的光线来自同一点，且方向辐射自四面八方。如蜡烛的光，萤火虫的光。</p>
<p>点光源用PointLight表示，构造函数如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">PointLight</span><span class="params">(color, intensity, distance)</span></span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>color：光的颜色</li>
<li>intensity：光的强度，默认1.0，即100%强度的光</li>
<li>distance：光的距离，从光源所在的位置，经过distance距离后，光的强度将从intensity衰减到0，默认为0，表示光源强度不衰减</li>
</ul>
<h3 id="聚光灯">聚光灯</h3><p>这种光源的光线从一个锥体中射出，在被照射的物体上产生聚光的效果。使用这种光源需要指定光的射出方向以及椎体的顶角。</p>
<p>聚光灯的构造函数如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.<span class="function"><span class="title">SpotLight</span><span class="params">(hex, intensity, distance, angle, exponent)</span></span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>hex：聚光灯发出的颜色</li>
<li>intensity：光源的强度，默认1.0</li>
<li>distance：光线的强度从最大值衰减到0需要的距离，默认为0，表示不衰减</li>
<li>angle：聚光灯着色的角度，用弧度作为单位，这个角度是和光源方向形成的角度</li>
<li>exponent：光源模型中，衰减的一个参数，越大衰减越快</li>
</ul>
<h3 id="材质与光源的关系">材质与光源的关系</h3><p>材质就是材料和质感的完美结合。</p>
<p>渲染程序中，材质是表面各种可视属性的结合，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。</p>
<p>材质的真相仍然是光，离开光材质是无法体现的。</p>
<h4 id="不带任何光源的物体">不带任何光源的物体</h4><p>画一个物体，不带任何的光源，定义物体颜色为黑色，定义材质如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">	color: <span class="number">0x000000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当没有光源的时候，最终的颜色将是材质的颜色。</p>
<h4 id="材质与光源">材质与光源</h4><p>最常见的材质之一就是Lambert材质，这是在灰暗或不光滑的表面产生均匀散射而形成的材质类型。Lambert材质表面会在所有方向上均匀地散射灯光，这就会使颜色看上去比较均匀。</p>
<p>Lambert材质会受环境光的影响，呈现环境光的颜色，与材质本身颜色关系不大。</p>
<h4 id="环境光对物体的影响">环境光对物体的影响</h4><p>环境光就是在场景中无处不在的光，它对物体的影响是均匀的，也就是无论从物体的那个角度观察，物体的颜色都是一样的。</p>
<h3 id="平行光">平行光</h3><p>平行光又称为方向光，是一组没有衰减的平行的光线，类似太阳光的效果。</p>
<p>方向光的构造函数如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.<span class="function"><span class="title">DirectionalLight</span><span class="params">(hex, intensity)</span></span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>hex：关系的颜色，用16进制表示</li>
<li>intensity：光线的强度，默认为1</li>
</ul>
<p>平行光有一个方向，它的方向是如何决定的呢？方向由位置和原点（0, 0, 0）来决定，方向光只与方向有关，与离物体的远近无关。</p>
<h3 id="环境光与方向光">环境光与方向光</h3><p>当环境光与方向光同时存在的时候，会出现怎么样的情况呢？</p>
<p>可以把这种情况想成两种光源同时作用于物体，它产生的情况，和每种光源分别作用于物体，然后将两者的结果相加是一样的效果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">initLight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	light = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x00FF00</span>)</span><br><span class="line">	light.position.<span class="built_in">set</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">	scene.add(light)</span><br><span class="line"></span><br><span class="line">	light = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xFF0000</span>)</span><br><span class="line">	light.position.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	scene.add(light)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当方向光照射过来的时候，被照射的表面呈现光的颜色，而由于是方向光，没有照射到的表面，就呈现暗色，一般是黑色，表示没有任何光源照到该表面。</p>
<h3 id="点光源-1">点光源</h3><p>点光源的特点是发光部分为一个小圆点，近似一个点。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">light = new THREE.<span class="function"><span class="title">PointLight</span><span class="params">(<span class="number">0</span>xFF0000)</span></span></span><br><span class="line">light<span class="class">.position</span><span class="class">.set</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>)</span><br><span class="line"><span class="function"><span class="title">scene</span><span class="params">(light)</span></span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/08/Three-js中的相机/" itemprop="url">
                  Three.js中的相机
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-08T21:14:11+08:00" content="2017-02-08">
              2017-02-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="相机种类">相机种类</h3><p>在Three.js中，相机的表示是THREE.Camera，它是相机的抽象基类，其子类有两个，分别是正投影相机和透视投影相机。</p>
<ul>
<li>正投影相机：THREE.OrthographicCamera</li>
<li>透视投影相机：THREE.PerspectiveCmaera</li>
</ul>
<h3 id="两者的区别">两者的区别</h3><p>正投影相机和透视投影相机的区别是：透视投影有一个基本点，就是远处的物体比近处的物体小；正投影远近高低比例都相同。</p>
<h4 id="正投影相机">正投影相机</h4><p>正投影相机的构造函数：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OrthographicCamera</span>(<span class="attribute">left</span>, <span class="attribute">right</span>, <span class="attribute">top</span>, <span class="attribute">bottom</span>, near, far)</span><br></pre></td></tr></table></figure>
<p>构造函数参数说明：</p>
<ul>
<li>left参数：左平面距离相机中心点的垂直距离</li>
<li>right参数：右平面距离相机中心点的垂直距离</li>
<li>top参数：顶平面距离相机中心点的垂直距离</li>
<li>bottom参数：底平面距离相机中心点的垂直距离</li>
<li>near参数：近平面距离相机中心点的垂直距离</li>
<li>far参数：远平面距离相机中心点的垂直距离</li>
</ul>
<p>相机的中心点可以定义为相机的位置。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">camera</span> = <span class="keyword">new</span> THREE.OrthographicCamera(<span class="variable">width</span>/-<span class="number">2</span>, <span class="variable">width</span>/<span class="number">2</span>, <span class="variable">height</span>/<span class="number">2</span>, <span class="variable">height</span>/-<span class="number">2</span>, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">scene.<span class="built_in">add</span>(<span class="built_in">camera</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码就是将浏览器窗口的宽度和高度作为了视景体的高度和宽度，相机正好在窗口的中心点上。</p>
<h4 id="透视投影相机">透视投影相机</h4><p>透视投影相机的构造函数如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">PerspectiveCamera</span><span class="params">(fov, aspect, near, far)</span></span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>视角fov：视角大小</li>
<li>近平面near：近处的平面的距离</li>
<li>远平面far：远处的平面</li>
<li>纵横比aspect：宽度除以高度</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> camera = new THREE.<span class="function"><span class="title">PerspectiveCamera</span><span class="params">(<span class="number">45</span>, width/height, <span class="number">1</span>, <span class="number">1000</span>)</span></span></span><br><span class="line">scene.<span class="function"><span class="title">add</span><span class="params">(camera)</span></span></span><br></pre></td></tr></table></figure>
<p>视角越大，中间的物体越小，这是因为视角越大，看到的场景越大，中间物体相对于整个场景来说，就会越小。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/23/Immutable-js中文API文档-持续更新/" itemprop="url">
                  Immutable.js中文API文档(持续更新)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-23T22:35:39+08:00" content="2016-09-23">
              2016-09-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>不可变数据鼓励使用纯函数（相同的输入，输出永远相同），并适用于更简单的应用程序开发和使用函数式编程实现的技术，如延迟计算。</p>
<p>这样的设计给JS提供了一些强大的函数概念，它提供了JS工程师都很熟悉的面向对象API及与原生JS很类似的Array、Map和Set，可以很方便高效地和普通JS对象进行转换。</p>
<p>友情提示：所有的示例都使用ES6编写，如果要在浏览器中运行，则需要转为ES3，如下所示：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6</span></span><br><span class="line">foo.mao( x =&gt; x*x)</span><br><span class="line"><span class="comment">//ES3</span></span><br><span class="line">foo.map(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x*x</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="API">API</h2><h3 id="fromJS()">fromJS()</h3><p>将普通JS对象和数组转换为不可变的Map和List集合。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fromJS(json: <span class="built_in">any</span>, reviver?: (k: <span class="built_in">any</span>, v: Iterable&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;) =&gt; <span class="built_in">any</span>) : <span class="built_in">any</span></span><br></pre></td></tr></table></figure>
<p>如果提供了可选的reviver参数，它将作为一个Seq被每个集合调用（从嵌套最深的集合开始直到最顶层的集合本身），Seq包含一个指向每个集合的key以及父级JS对象作为this使用。在最顶层的Object，key为””，reviver预计返回一个新的Immutable Iterable，允许从深嵌套的JS对象自定义转换。</p>
<p>将JSON对象转为List和OrderedMap：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Immutable.fromJS(&#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="number">40</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(key, <span class="keyword">value</span>) &#123;</span><br><span class="line">  var isIndexed = Immutable.Iterable.isIndexed(value)</span><br><span class="line">  return isIndexed ? value.toList() : value.toOrderMap()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//true:, <span class="string">'b'</span>, &#123;b: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]&#125;</span><br><span class="line">//<span class="literal">false</span>, <span class="string">'a'</span>, &#123;a: &#123;b: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]&#125;, c: <span class="number">40</span>&#125;</span><br><span class="line">//<span class="literal">false</span>, <span class="string">''</span>, &#123; <span class="string">''</span>: &#123;a: &#123;b: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]&#125;, c: <span class="number">40</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有提供reviver参数，则默认将Arrays转为List集合，将Objects转为Map集合。</p>
<p>当和JSON.parse有同样的参数时候reviver也会起作用。</p>
<p>Immutable.fromJS()是保守的转换。它的转换规则是：仅仅使用Array.isArray将数组转为List集合，将原始对象（不定制原型）转为Map集合。</p>
<p>请记住：即便是一些引用的简写及不可变Map集合接受任意类型的key，当将JS对象转为不可变的Map集合时，JS对象的属性始终是字符串。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="number">1</span>: <span class="string">'one'</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">//['1']</span></span><br><span class="line">obj[<span class="string">'1'</span>] <span class="comment">//one</span></span><br><span class="line">obj[<span class="number">1</span>] <span class="comment">//one</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Map</span>(obj)</span><br><span class="line">map.<span class="literal">get</span>(<span class="string">'1'</span>) <span class="comment">//one</span></span><br><span class="line">map.<span class="literal">get</span>(<span class="number">1</span>) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>因为不可变Map集合的key可以是任意类型，所以访问JS对象属性时候首次会将key转为字符串，以防get()方法被修改。</p>
<h3 id="is()">is()</h3><p>值相对检测相当于Object.js，但是is()方法将Immutable Iterable作为value，检测是否与第二个Iterable包含的值相对。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">is</span>(<span class="keyword">first</span>: any, <span class="keyword">second</span>: any): <span class="type">boolean</span></span><br></pre></td></tr></table></figure>
<p>当检查是否相等时，它被用于整个不可变集合，包含Map集合key的比较急Set集合的成员比较。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = Immutable.<span class="built_in">Map</span>(&#123;a: <span class="number">1</span>, b: <span class="number">1</span>, c: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">var</span> map2 = Immutable.<span class="built_in">Map</span>(&#123;a: <span class="number">1</span>, b: <span class="number">1</span>, c: <span class="number">1</span>&#125;)</span><br><span class="line">map1 !== map2 <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(map1, map2); <span class="comment">//false</span></span><br><span class="line">Immutable.<span class="keyword">is</span>(map1, map2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Tips：不像Object.is，Immutable.js假定0和-0相等，匹配ES6 Map中的key是否相等。</p>
<h3 id="List">List</h3><p>List是按索引排序的密集型集合，和类似JS的Array。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List&lt;T&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Collection</span>.<span class="title">Indexed&lt;T&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>List集合是不可变的，充分可持久化的，get和set的时间复杂度为O(log32 N)，push和pop的时间复杂度为O(1)。</p>
<p>List实现了Deque，具有同时从尾部（push，pop）和头部（unshift，shift）高效地添加和移除元素。</p>
<p>与JS Array不同，未设置索引和设置了索引，然后将值设置为undefined是相同的行为，List的forEach方法从0到size访问所有的索引，而不管它们是否被明确定义。</p>
<p><strong>构造方法</strong></p>
<h3 id="List()">List()</h3><p>使用类似Iterable提供的值，创建一个新的不可变List，</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;T&gt;(): <span class="built_in">List</span>&lt;t&gt;</span><br><span class="line"><span class="built_in">List</span>&lt;T&gt;(iter: <span class="built_in">Iterable</span>.Indexed&lt;T&gt;): <span class="built_in">List</span>&lt;T&gt;</span><br><span class="line"><span class="built_in">List</span>&lt;T&gt;(iter: <span class="built_in">Iterable</span>.<span class="built_in">Set</span>&lt;T&gt;): <span class="built_in">List</span>&lt;T&gt;</span><br><span class="line"><span class="built_in">List</span>&lt;K, V&gt;(iter: <span class="built_in">Iterable</span>.Keyed&lt;K, V&gt;): <span class="built_in">List</span>&lt;any&gt;</span><br><span class="line"><span class="built_in">List</span>&lt;T&gt;(array: Array&lt;T&gt;): <span class="built_in">List</span>&lt;T&gt;</span><br><span class="line"><span class="built_in">List</span>&lt;T&gt;(iterator: <span class="built_in">Iterator</span>&lt;T&gt;): <span class="built_in">List</span>&lt;T&gt;</span><br><span class="line"><span class="built_in">List</span>&lt;T&gt;(iterable: <span class="built_in">Object</span>): <span class="built_in">List</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p><strong>静态方法</strong></p>
<h3 id="List-isList()">List.isList()</h3><p>如果提供的值是一个List，则返回true。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List.<span class="function"><span class="title">isList</span><span class="params">(maybeList: any)</span></span>: boolean</span><br></pre></td></tr></table></figure>
<h3 id="List-of()">List.of()</h3><p>使用包含的值创建一个新的List。</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>.<span class="keyword">of</span>&lt;T&gt;(...values: T[]): <span class="built_in">List</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p><strong>成员变量</strong></p>
<h3 id="size">size</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>: <span class="keyword">number</span></span><br></pre></td></tr></table></figure>
<p><strong>持久性更改</strong></p>
<h3 id="set()">set()</h3><p>返回一个包括索引值的新的List，如果该索引已经存在在List中，则替换它。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">set</span>(<span class="keyword">index</span>: <span class="built_in">number</span>, <span class="keyword">value</span>: <span class="keyword">T</span>): <span class="keyword">List</span>&lt;<span class="keyword">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>索引可能会是负数，就会从List尾部开始索引。v.set(-1, ‘value’)设置的是List集合中最后一个元素。</p>
<p>如果索引大于List的size，则尽可能大的返回包含该索引的size。</p>
<h3 id="delete()">delete()</h3><p>返回一个新的List，该List包含该索引值和比原List的size少1的List，该index所在位置上面的元素都会向下移动一位来填补空缺。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">delete</span>(<span class="keyword">index</span>: <span class="built_in">number</span>): <span class="keyword">List</span>&lt;<span class="keyword">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>与list.splice(index, 1)作用相同。</p>
<p>index可以是负数，如果索引是负数则从List尾部操作。v.delete(-1)会删除List中最后一个元素。</p>
<p>友情提示：delete方法在IE8下慎用。</p>
<h3 id="insert()">insert()</h3><p>返回一个索引值比原List的size大1的List，该索引位置及后面的元素依次向后移动1位。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">insert</span>(<span class="keyword">index</span>: <span class="built_in">number</span>, <span class="keyword">value</span>: <span class="keyword">T</span>): <span class="keyword">List</span>&lt;<span class="keyword">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>与list.splice(index, 0, value)作用相同。</p>
<h3 id="clear()">clear()</h3><p>返回一个size为0，并且没有值的新List。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">clear</span><span class="params">()</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure>
<h3 id="push()">push()</h3><p>返回一个新的List集合，参数values添加List中，从原List的size开始。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span><span class="params">(...values: T[])</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure>
<h3 id="pop()">pop()</h3><p>返回一个新的List集合，比原List的size小1，删除List中的最后一个元素。</p>
<p>友情提示：和Array#pop方法不同，因为它返回的是一个新的List集合而不是被删除的值。使用last()方法获取List集合中的最后一个值。</p>
<h3 id="unshift()">unshift()</h3><p>根据提供的参数，返回一个新的List集合，参数会添加到List头部。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">unshift</span><span class="params">(...values: T[])</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure>
<h3 id="shift()">shift()</h3><p>返回一个新的List集合，比原List的size小1，删除了原List的第一个元素，新List集合中元素的索引比原List中都小1。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">shift</span><span class="params">()</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>友情提示：和Array#shift()方法不同，因此该方法返回的是一个新的List集合，而不是被删除的元素。使用first()方法可以获取到List集合中的第一个元素。</p>
<h3 id="update()">update()</h3><p>update可接收三种不同类型的参数，都会返回一个新的List集合。</p>
<ul>
<li>只接收一个updater参数，该参数为function</li>
<li>接收两个参数：一个索引，类型为number；一个updater function</li>
<li>接收三个参数：一个索引；不设定值；一个updater function</li>
</ul>
<p>index可能为负数，如果为负数，则从List集合尾部操作。v.update(-1)更新List集合的最后一个元素。</p>
<h3 id="merge()">merge()</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">merge</span>(...iterables: Iterable.Indexed&lt;<span class="keyword">T</span>&gt;[]): <span class="keyword">List</span>&lt;<span class="keyword">T</span>&gt;</span><br><span class="line"><span class="keyword">merge</span>(...iterables: <span class="built_in">Array</span>&lt;<span class="keyword">T</span>&gt;[]): <span class="keyword">List</span>&lt;<span class="keyword">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="mergeWith()">mergeWith()</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mergeWith(</span><br><span class="line">	merger: (previous?: <span class="literal">T</span>, <span class="keyword">next</span>?: <span class="literal">T</span>, key?: number) =&gt; <span class="literal">T</span>,</span><br><span class="line">	...iterables: Iterable.Indexed&lt;<span class="literal">T</span>&gt;[]</span><br><span class="line">): List&lt;<span class="literal">T</span>&gt;</span><br><span class="line">mergeWith(</span><br><span class="line">	merger: (previous?: <span class="literal">T</span>, <span class="keyword">next</span>?: <span class="literal">T</span>, key?: number) =&gt; <span class="literal">T</span>,</span><br><span class="line">	...iterables: Array&lt;<span class="literal">T</span>&gt;[]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="mergeDeep">mergeDeep</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mergeDeep</span><span class="params">(...iterables: Iterable.Indexed&lt;T&gt;[])</span></span>: List&lt;T&gt;</span><br><span class="line"><span class="function"><span class="title">mergeDeep</span><span class="params">(...iterables: Array&lt;T&gt;[])</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure>
<h3 id="mergeDeepWith()">mergeDeepWith()</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mergeDeepWith(</span><br><span class="line">	merger: (previous?: <span class="literal">T</span>, <span class="keyword">next</span>?: <span class="literal">T</span>, key?: number) =&gt; <span class="literal">T</span>,</span><br><span class="line">	...iterables: Iterable.Indexed&lt;<span class="literal">T</span>&gt;[]</span><br><span class="line">): List&lt;<span class="literal">T</span>&gt;</span><br><span class="line">mergeDeepWith(</span><br><span class="line">	merger: (previous?: <span class="literal">T</span>, <span class="keyword">next</span>?: <span class="literal">T</span>, key?: number) =&gt; <span class="literal">T</span>,</span><br><span class="line">	...iterables: Array&lt;<span class="literal">T</span>&gt;[]</span><br><span class="line">): List&lt;<span class="literal">T</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="setSize()">setSize()</h3><p>根据参数size返回一个新的List集合。</p>
<ul>
<li>size小于原List集合的size，则返回size长度的一个List；</li>
<li>size大于原List集合的size，则不足的部分填充undefined</li>
</ul>
<p><strong>深度持久化</strong></p>
<h3 id="setIn()">setIn()</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/23/React设计原则/" itemprop="url">
                  React设计原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-23T22:30:09+08:00" content="2016-09-23">
              2016-09-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Composition">Composition</h2><p>React的关键特性就是组件的组合。不同人开发的组件应该能够很好的协同工作。向一个组件中添加功能不会引起整个代码库的动荡，这点对我们而言是很重要的。</p>
<p>比如说，应该向组件中添加一些本地state而不应该修改任何引用它的组件。相同地，当必要时候也可能向任何组件添加一些初始化和卸载的代码。</p>
<p>关于在组件中使用state或生命周期方法，并不是不好的方式。就像任何复杂功能，他们就应该适当的使用这些，我们也并不打算移除它们。相反，我们认为它们是使用React过程中的不可分割的一部分。将来我们可能会添加很多功能模式，本地state和生命周期方法都将会是其一部分。</p>
<p>组件经常为描述为只是一个Function，然而在我们的视图中，它需要有更多的用途。在React中，描述组件的任何组合行为时，就包含渲染、生命周期和state。一些第三方库，如Relay来增强组件的描述数据依赖的职责。某些情况下，这些想法可能会使它回退到React中。</p>
<h2 id="Common_Abstraction">Common Abstraction</h2><p>一般来说，我们抵制添加一些可以在用户层面实现的功能。我们不希望由于这些无用的库文件导致你的应用膨胀。不过，也有例外情况。</p>
<p>比如，如果React不提供对本地state或生命周期方法的支持，人们想要对它们创建通用的抽象。当有多个抽象竞争时，React不能强制或利用任何一个的性能优势。它会以两者最低的共同标准来工作。</p>
<p>这也是为什么有时我们向React本身添加一些功能。如果我们注意到很多组件都实现了一些兼容和效率不高的功能时，我们更倾向于将它们添加到React里面。我们不会轻描淡写地去做。当我们这样做的时候，是因为我们相信提高抽象层次更有利于整个生态系统。state、生命周期、跨浏览器事件标准化都是很好的例子。</p>
<h2 id="Escape_Hatches">Escape Hatches</h2><p>React是实用的。它是Facebook在产品需求驱动下开发的。虽然它受到一些还不是很主流的规范的影响，如函数式编程，和更广范围内的不同技能和经验水平的开发者保持接触是该项目一个明确的目标。</p>
<p>如果我们想要废弃一个我们不喜欢的模式，在废弃之前考虑到它现有的所有用例和社区相关的替代品，这是我们的责任。如果一些在构建应用方法很有用的模式很难使用声明式的方式来表达，我们将会提供一个命令式的API。如果我们不能向很多我们发现的有必要的应用提供一个完美的API，我们将会提供一个临时的欠佳的API，因为后期它是可以被废弃的，这也为今后的改进敞开了大门。</p>
<h2 id="Stability">Stability</h2><p>我们很重视API的稳定性。在Facebook中，我们有超过2000个组件是使用React的。许多其他公司，包括Twitter和Airbnb，也在使用React。这也就是为什么我们通常都不愿意改变公共的API和其行为。</p>
<p>然而，我们认为“没有任何改变”的稳定性在这个意义上被高估了。这样会快速地停歇下来。相反，我们更喜欢这种意义上的稳定性：在生产中大量使用，当更新了的时候，有一个明显的（最好是自动）路径迁移。</p>
<p>当我们废弃一个模式时候，我们会先在Facebook内部研究使用和添加废弃警告。他们让我们评估变化带来的影响。有时候，如果我们发现这种变化太早了，我们就会回退，我们需要将更多的战略性思考过的代码加入到代码库中，在这个点上，他们已经准备好了接受这种变化。如果我们确认了这种变化不是很具破坏性，并且迁移策略对所有用例都是可行的，我们将会在开源社区发布废弃警告的声明。我们正在与Facebook以外的React用户联系，我们监测流行的开源项目，指导他们解决这些弃用的问题。</p>
<p>鉴于Facebook庞大的React代码库规模，成功的内部迁移往往是一个很好的指标，其他公司将不会有任何问题。不过有时也会有人指出一些我们没有想到的额外使用的情况，我们为他们增加escape hatches，或重新考虑我们的做法。</p>
<p>没有一个很好的理由，我们是不会废弃任何东西的。我们承认，有时一些警告会导致挫折感，但我们加入它们，因为这样为改进和增加新功能扫清了障碍，社区中的很多人都认为这些改进和新功能是有价值的。</p>
<p>比如，在React0.15.2版本中，我们增加了识别不了DOM属性的警告。许多项目受此影响。但是，解决这种警告是很重要的，我们引入了对React自定义属性的支持。这就是我们每增加一个弃用背后的原因。</p>
<p>当我们添加一个弃用警告，我们保证在当前主要版本可以放心使用的，会在下一个主要版本中进行修改。如果有很多涉及到重复的手工劳动，我们realease了大部分自动变化的codemod脚本。Codemods使得我们可以继续前进而不是在一个庞大的代码库前停滞，我们鼓励您使用它们。</p>
<p>你可以在<a href="https://github.com/reactjs/react-codemod" target="_blank" rel="external">react-codemod</a>找到我们release的codemod。</p>
<h2 id="Interoperability">Interoperability</h2><p>我们和现有的系统和逐步过渡的有高价值的项目在互通。Facebook拥有一个庞大的非React代码库。它的网站使用名为XHP的一个服务器端组件的系统，它的内部UI库就是使用的React。任何团队的产品都可以在一个小功能上使用React，而不是重写代码，这对我们来说是很重要的。</p>
<p>这就是为什么React为多种模式的工作提供了escape hatches，并试图与其他UI库很好的协同工作。你可以在一个声明式组件中包裹现有的命令式UI，反之亦然。这是逐步采用的关键。</p>
<h2 id="Scheduling">Scheduling</h2><p>即使你使用function来定义组件，当你使用React时不能直接调用他们。每个组件都会返回对需要渲染内容的描述，这个描述包括用户自己编写的组件，如<likebutton>，和平台提供的具体组件，如<div>。在某个时间点上依靠React来解析<likebutton>，根据递归渲染组件的结果来更新UI树。</likebutton></div></likebutton></p>
<p>这是一个微妙但功能强大的区别。因此你不用调用React的组件功能，而是让React调用它，这就意味着在需要的时候，React有延迟调用它的权利。目前实现的React递归渲染树和调用整个更新树的功能是在单个tick期间。然而，未来它可能会开始延迟一些更新，以避免丢帧现象。</p>
<p>React设计中这是一个通用的主题。一些流行的库实现“PUSH”的方式是当有新数据可用的时候来计算执行。React不同，坚持使用“PULL”的方式，只有当需要的时候才去计算。</p>
<p>React不是一个普通的数据处理库。它是一个构建用户界面的库。我们认为这是在一个应用中唯一可以定位那些计算需要立刻执行和哪些不需要。</p>
<p>没有在当前屏幕中显示的，我们可以延迟其相关的任何逻辑计算。如果接收到数据比帧速快，我们可以合并并批量更新。我们会优先考虑从用户交互（如点击一个按钮触发动画）而不是一些不是很重要的幕后的工作（如渲染从网络加载的内容），以避免出现丢帧现象。</p>
<p>需要声明的是，我们并没有采取这一权利的优势。然而可以自由选择如何做，这就是为什么我们宁愿在调度时候控制，这也是为什么setState()是异步的。从概念上讲，我们认为它是“调度更新”。</p>
<p>如果让用户在一些常见的函数式编程模式下直接基于“PUSH”模式编写视图，这将会很难在调度的时候去做控制。我们希望拥有“glue”代码。对于React而言这是关键的目标，返回到React中之前，执行的用户代码量是最少的。这也确保了React具有调度和根据它所知道的UI来进行块分割的能力。</p>
<p>在团队内部都戏称React应该被叫做“调度程序”，因为React并不想完全没有活性。</p>
<h2 id="Developer_Experience">Developer Experience</h2><p>对我们而言，提供一个良好的开发者体验是很重要的。</p>
<p>比如，我们维护的React DevTools可以让你在Chrome和Firefox中检查React组件树。我们从Facebook工程师和社区中听说到它极大地提升了开发效率。我们也试图做一些额外的努力，为了给开发者提供一些有用的警告信息。比如，在开发环境下，如果你以某种方式嵌套的标签浏览器不能识别，或在API中犯了一个通常的拼写错误，React就会给出警告提示。开发环境下的警告和相关检查是React开发版本比生产版本慢的主要原因。</p>
<p>在Facebook内部我们看到的使用模式有助于我们了解常见的错误是什么，以及如何提前预防它们。当我们添加新的功能时，我们也会尝试预见到常见的错误和警告。</p>
<p>我们一直在探索提高开发体验的方式。我们乐意倾听您的建议，并接受您的贡献，使得React变得更好。</p>
<h2 id="Debugging">Debugging</h2><p>当出现错误的时候，在代码库的源码中有breadcrumbs来跟踪错误是很重要的。在React中，props和state就是这些breadcrumbs。</p>
<p>如果发生了错误，你可以打开React DevTools，找到渲染的组件，验证下props和state是否正确。如果都正确，则你就知道问题是出在了组件的render()方法上，或者一些调用render()方法的方法。这些问题都是孤立的。</p>
<p>如果state是错误的，你就知道是文件中某处调用setState()方法导致的错误。相对来说找到并修复这样的问题也是比较简单的，因为在一个文件中不会有太多的setState()被调用。</p>
<p>如果props是错误的，你可以遍历并检查整个树，找出第一个向下传递错误props的组件。</p>
<p>在React中，跟踪任何UI上通过当前props和state产生的数据的能力是非常重要的。 state在闭包和组合中是不受控的，可直接被React使用，这是一个非常明确的设计目标。</p>
<p>虽然UI是动态的，但我们相信相对于调试时候无聊的推测props和state的过程，同步的render()是确定的。我们希望在React中保持这种约束，即便是在更复杂的用例中，如复杂的动画，或更复杂的情况。</p>
<h2 id="Configuration">Configuration</h2><p>我们发现全局运行时配置选项是有问题的。</p>
<p>例如，偶尔要求我们实现如React.configure(options)或React.register(component)的方法。然而这会带来很多问题，我们并没有很好的解决方案。</p>
<p>如果有人调用第三方组件库中的方法会发生什么？如果一个React应用中嵌入了另一个React应用，而他们需要的配置不兼容会发生什么？怎会有一个第三方组件指定它需要一个特定的配置？我们认为全局配置不能很好的组合工作。由于组合是React的核心，因此在代码中我们不在提供全局配置。</p>
<p>我们的确这样做了，但在构建级别提供了一些全局配置。比如，我们单独提供开发和生产版本。将来我们也可能会提供一个性能分析的build，我们也会考虑其他构建标识。</p>
<h2 id="Beyond_the_DOM">Beyond the DOM</h2><p>我们可以看到React在开发的组件BUG很少以及组件相互组合方面的价值。DOM是React的原始渲染目标，但React Native对Facebook和社区是同等重要的。</p>
<p>成为渲染器无关是一个非常重要的React的设计约束。在内部表现方面增加了一些开销。另一方面，在跨平台兼容方面有核心的改进。</p>
<p>让开发产品成为一种单一的开发模式，而不是基于平台形式的工程团队。到目前为止，对我们而言这种权衡是有价值的。</p>
<h2 id="Implementation">Implementation</h2><p>在任何可能的条件下我们都尝试提供优雅的API。我们很少关注如何优雅的实现。现实和完美差的很远，在合理的范围内，如果意味着用户不用写时，我们愿意将一些丑陋的代码添加到代码库中。当我们评估新代码时，我们寻找正确的实现，优异的性能和良好的开发体验。优雅是次要的。</p>
<p>我们宁愿将无趣的代码转变为巧妙的代码。代码一次性使用和经常改变的。因此，除非非常有必要，否则不要引入新的内部抽象是非常重要的。冗余的代码很容易到处都是，修改和删除是实现优雅的最好方式，最好提前抽象和不要轻易改变。</p>
<h2 id="Optimized_for_Tooling">Optimized for Tooling</h2><p>一些常用的API有冗长的API。如，我们使用componentDidMount()代替didMount()和onMount()。这是故意而为的。目的就是当看到这些API时就知道是React里面的。</p>
<p>在Facebook这样一个庞大的代码库中，能够搜索特定的API是非常重要的。我们很重视冗长的命名，尤其是对那些谨慎使用的功能。例如，dangerouslySetInnerHTML在代码审查中很难通过。</p>
<p>优化搜索也是很重要的，因为我们依赖codemods打断点跟踪变化。在整个代码库中，我们希望它是简单并安全的自动应用变化，这些冗长的命令可以帮我们实现这一目标。同样地，这些与众不同的命名可以让我们很容易的使用React编写自定义规则，而不用担心潜在的冲突。</p>
<p>JSX起着类似的作用。然而，React中它并不是必须的，Facebook内部广泛的使用它是基于美观和实用的原因。</p>
<p>在我们的代码库中，JSX只是作为处理React元素树的一个工具。这就使得可以在编译时间上优化，如提升常量元素，安全检测和codemod内部组件的使用，并且JSX的警告可以定位到源代码位置。</p>
<h2 id="Dogfooding">Dogfooding</h2><p>我们尽我们所能解决社区提出的问题。</p>
<p>然而，我们可能会优先解决Facebook内部遇到的问题。可能与直觉相反，我们认为这也是为什么社区参与到React中的原因。</p>
<p>重视内部使用给了我们React不会很快销声匿迹的信心。React是Facebook创建的，是为了解决自己的问题。它为公司带来了实实在在的商业价值，并在许多产品中都使用到了它。内部测试意味着我们有一个清晰的愿景，我们在向一个集中的目标前进。</p>
<p>这并不意味着我们会忽略社区提出的各种问题。例如，React中我们加入了对web components和svg的支持，即使我们不依赖它们中的任一个。我们正在倾听你的痛点，并尽我们所能解决它们。React社区是专门为我们开设的，我们很荣幸能够做出贡献。</p>
<p>在Facebook上发布许多开源项目后，我们已经了解到，让每个人都很快乐地开发项目而不专注是不良循环。相反，我们发现选择一小部分人，并着眼于使它们快乐会带来积极的影响。这正是我们用React所做的事情，到目前为止，解决Facebook内部遇到的问题已经转化为良好的开源社区。</p>
<p>这种做法的缺点是，有时要处理Facebook团队内部的事情而没能给足够的关注，如“getting started”体验。我们已经强烈地意识到了这一点，我们正在考虑，如何改进这一方式，让社区中的每个人都不会犯我们之前在维护开源项目上所犯的相同的错误。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/27/keyed-Fragments/" itemprop="url">
                  keyed Fragments
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-27T13:39:43+08:00" content="2016-06-27">
              2016-06-27
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大多数情况下，可以使用prop的key指定render方法返回的元素的key。然而，这里有一个例外情况：如果有两个需要排序的子元素，则没有办法把一个key作用到每一个子元素上，除非添加一个元素把他们包起来。</p>
<p>也就是说，如果你有这样的组件：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Swapper = React.createClass(&#123;</span><br><span class="line">	propTypes: &#123;</span><br><span class="line">		leftChildren: React.PropTypes.node,</span><br><span class="line">		rightChidlren: React.PropTypes.node,</span><br><span class="line">		swapped: React.PropTypes.bool</span><br><span class="line">	&#125;,</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> children;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.props.swapped) &#123;</span><br><span class="line">			chidlren = [<span class="keyword">this</span>.props.rightChilren, <span class="keyword">this</span>.props.leftChildren];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			chidlren = [<span class="keyword">this</span>.props.leftChildren, <span class="keyword">this</span>.props.rightChilren];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当改变了包装元素的prop后，子元素都将会被卸载并且重现加载，因为这里没有任何key可以同时标注在所有子元素上。</p>
<p>为了解决这个问题，你可以使用createFragment附加key给子元素。</p>
<h3 id="Array_createFragment(object_children)">Array<reactnode> createFragment(object children)</reactnode></h3><p>而不是创建数组，可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> crateFragment = <span class="built_in">require</span>(<span class="string">'react-addons-create-fragment'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.props.swapped) &#123;</span><br><span class="line">	children = createFragment(&#123;</span><br><span class="line">		right: <span class="keyword">this</span>.props.rightChildren,</span><br><span class="line">		left: <span class="keyword">this</span>.props.leftChildren</span><br><span class="line">	&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	children = createFragment(&#123;</span><br><span class="line">		left: <span class="keyword">this</span>.props.leftChildren,</span><br><span class="line">		right: <span class="keyword">this</span>.props.rightChildren</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递的对象（即left和right）的key作用于集合中的所有子元素，对象的key的顺序确定渲染子元素的顺序。这种修改后，子元素在DOM中将适当重新排序而没有卸载。</p>
<p>createFragment的返回值应视为一个不透明的对象；可以使用React.Children helpers通过一个fragment来循环，而不应该直接访问它。还要注意的是我们依靠JS引擎确保对象的枚举顺序，它不受规范保护，但被所有主流浏览器和虚拟机通过非数字键的对象来实现。</p>
<p><strong>Note</strong></p>
<p>将来，createFragment也许被如下的API代替：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">return <span class="list">(</span><br><span class="line">	<span class="keyword">&lt;div&gt;</span></span><br><span class="line">		&lt;x<span class="keyword">:frag</span> key=<span class="quoted">'right</span><span class="quoted">'&gt;</span>&#123;this.props.rightChildren&#125;&lt;/x<span class="keyword">:frag&gt;</span></span><br><span class="line">		&lt;x<span class="keyword">:frag</span> key=<span class="quoted">'left</span><span class="quoted">'&gt;</span>&#123;this.props.leftChildren&#125;&lt;/x<span class="keyword">:frag&gt;</span></span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>
<p>允许我们直接在JSX上指定键，而不用添加包装元素。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/27/翻译-React性能优化/" itemprop="url">
                  [翻译]React性能优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-27T09:36:04+08:00" content="2016-06-27">
              2016-06-27
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>考虑是否使用react开发项目时，人们第一个反应就是react开发的应用程序的响应速度和非React应用程序相比哪个更快。每一个state状态的改变都会引起组件树的重新渲染，使得人们怀疑这种机制是否会对性能造成影响。React使用几个巧妙的技巧来最小化更新UI，避免昂贵的DOM操作。</p>
<h3 id="使用生产版本">使用生产版本</h3><p>如果你发现了React应用的性能问题，请确保使用的是压缩后的生产版本。开发版包括了一些额外的警告信息，在开发应用过程中非常有用，但由于要记录额外的信息，因此相比生产版本较慢。</p>
<h3 id="避免调和DOM">避免调和DOM</h3><p>React使用虚拟DOM，在浏览器中呈现的是DOM树的描述。同时，React中应避免创建DOM节点和访问现有的DOM元素，因为这样要比操作JS对象慢。当一个组件的Props或state改变时，React通过构建一个新的虚拟DOM和旧的进行比较，来决定是否有必要更新实际的DOM。只有在它们不等的情况下，React才会尽可能小的更新DOM。</p>
<p>在此之上，React提供了一个组件生命周期函数，shouldComponentUpdate，该方法在组件重新渲染之前触发，开发人员可以决定是否进行渲染。该方法默认返回true，React执行更新：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate: <span class="function"><span class="keyword">function</span><span class="params">(nextProps, nextState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请记住，React会经常调用这个方法，因此该方法中的逻辑实现要尽可能的快。</p>
<p>假设你有一个消息应用的几个即时消息线程。假设只有一个线程改变了，如果我们在ChatThread组件上实现了shouldComponentUpdate方法，React就会跳过其他线程的渲染：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate: <span class="function"><span class="keyword">function</span><span class="params">(nextProps, nextState)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，总之，React允许用户在shouldComponentUpdate方法中取消渲染过程，避免昂贵的DOM更新操作，并且，对于哪些必须的，通过比较虚拟DOM来更新。</p>
<h3 id="shouldComponentUpdate_in_action">shouldComponentUpdate in action</h3><p>有一个组件的子树。每一个shouldComponentUpdate的返回值都取决于虚拟DOM的比较结果。最后，圆圈的颜色就表明组件是否需要被调和。</p>
<p>在上面的例子中，因为shouldComponentUpdate在子树C2节点上返回false，React就不会生成新的虚拟DOM，因此，也就不需要调和DOM。需要注意的是React在C4和C5上甚至都没有调用shouldComponentUpdate。</p>
<p>C1和C3节点shouldComponentUpdate返回true，因此React需要深入到子叶去比对。C6返回true，由于虚拟DOM不相等，需要调和DOM。最有趣的节点是C8，对于该节点，React必须计算虚拟DOM，但由于和旧的不相等，因此不需要调和DOM。</p>
<p>请注意，React只有在C6节点上需要做DOM更新，这是不可避免的。对于C8，通过比较虚拟DOM确定了它们不需要调和，对于C2的子树和C7，甚至都没有计算虚拟DOM，通过shouldComponentUpdate来进行确认。</p>
<p>那么，我们应该如何实现shouldComponentUpdate呢？假设有一个渲染一个字符串的组件：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">React.createClass(&#123;</span><br><span class="line">	propTypes: &#123;</span><br><span class="line">		<span class="keyword">value</span>: React.PropTypes.string.isRequired</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;&#123;this.props.<span class="keyword">value</span>&#125;&lt;/div&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以很容易的实现shouldComponentUpdate：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate: <span class="function"><span class="keyword">function</span><span class="params">(nextProps, nextState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.props.value !== nextProps.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理这种简单的props和state结构是比较容易的。但是，组件的props或state是可变的数据结果呢？如果props接收一个JS对象，包括一个字符串，如{foo: ‘bar’}：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">React.createClass(&#123;</span><br><span class="line">	propTypes: &#123;</span><br><span class="line">		<span class="keyword">value</span>: React.PropTypes.<span class="keyword">object</span>.isRequired</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	render: <span class="keyword">function</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;&#123;<span class="keyword">this</span>.props.<span class="keyword">value</span>.foo&#125;&lt;/div&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>shouldComponentUpdate的实现并不总是符合预期的。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.<span class="keyword">value</span> = &#123;foo: <span class="string">'bar'</span>&#125;</span><br><span class="line">nextProps.<span class="keyword">value</span> = &#123;foo: <span class="string">'bar'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是两个不同的引用</span></span><br><span class="line"><span class="keyword">this</span>.props.<span class="keyword">value</span> !== nextProps.<span class="keyword">value</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>问题是当props没有改变的时候shouldComponentUpdate居然返回true。为了解决这个问题，我们可以使用如下实现方式：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate: <span class="function"><span class="keyword">function</span><span class="params">(nextProps, nextState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.props.value.foo !== nextProps.value.foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上，我们最终做了深度的比较，以确保我们正确的跟踪变化。在性能方面，这种做法是非常昂贵的。它不能扩展，我们不得为每个模块便携不同的深度比较的方法。最重要的是，如果我们没能很好的管理对象的引用，它可能就会不起作用。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">React.createClass(&#123;</span><br><span class="line">	getInitialState: <span class="keyword">function</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="keyword">value</span>: &#123;</span><br><span class="line">				foo: <span class="string">'bar'</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line">	onClick: <span class="keyword">function</span>() &#123;</span><br><span class="line">		var <span class="keyword">value</span> = <span class="keyword">this</span>.state.<span class="keyword">value</span>;</span><br><span class="line">		<span class="keyword">value</span>.foo += <span class="string">'bar'</span>; </span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">			<span class="keyword">value</span>: <span class="keyword">value</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">	render: <span class="keyword">function</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;InnerComponent <span class="keyword">value</span>=&#123;<span class="keyword">this</span>.state.<span class="keyword">value</span>&#125; /&gt;</span><br><span class="line">				&lt;a onClick=&#123;<span class="keyword">this</span>.onClick&#125;&gt;Click Me&lt;/a&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>内部组件先被渲染，{foo: ‘bar’}作为它的props。如果用户点击了a链接，则父组件的state被更新为{value: {foo: ‘barbar’}}，触发内部组件重新渲染，它将接收新的props值{foo: ‘barbar’}。</p>
<p>这个问题是由于父组件和子组件引用同一个对象，当对象在onClick方法中变了时，子组件的props也跟着改变了。因此，当重渲染过程开始时，shouldComponentUpdate方法就会被调用，this.props.value.foo和nextProps.value.foo相等，实际上，this.props.value和nextProps.value引用的是同一个对象。</p>
<p>因此，我们就会想到prop的改变和阻止重新渲染的过程，bar变成barbar时UI将不会被更新。</p>
<h3 id="Immutable-js_to_the_rescue">Immutable-js to the rescue</h3><p>Immutable-js通过结构共享，提供了不可变持久化数据集合。</p>
<ul>
<li>Immutable（不可变）：一旦创建，集合就不能在另一个时间点被改变；</li>
<li>Persistent（持久性）：新的集合可以由以前的集合创建。创建新的集合后对原始集合依然有效；</li>
<li>Structural Sharing（结构共享）：创建新集合时候尽可能使用有相同结构的原始集合，将复制过程减少到最小，以实现空间效率和可接受的性能。如果新集合和原始集合相同，则返回原始集合。</li>
</ul>
<p>不可变使得追踪变化很容易，一个变化总是在新对象的结果中 ，因此只需检查这个对象的引用是否改变。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = &#123;foo: <span class="string">'bar'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> y = x;</span><br><span class="line">y.foo = <span class="string">'baz'</span>;</span><br><span class="line">x === y; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>虽然y被编辑了，由于它和x引用的是同一个对象，因此这种比较返回true。然而，这种代码可以使用不可变JS来写：</p>
<pre><code><span class="keyword">var</span> SomeRecord = Immutable.Record({foo: <span class="literal">null</span>});
<span class="keyword">var</span> x = <span class="keyword">new</span> SomeRecord({foo: <span class="string">'bar'</span>});
<span class="keyword">var</span> y = x.<span class="keyword">set</span>(<span class="string">'foo'</span>, <span class="string">'baz'</span>);
x === y; <span class="comment">// false</span>
</code></pre><p>在这种情况下，当x改变时候返回一个新的引用，我们可以更安全的假定x已经改变。</p>
<p>另一种可能就是设置一个标识，通过脏检查来跟踪变化。这种方法的一个问题是强制我们使用setters，既要写很多无关的代码，又和代码类耦合。或者，在一个对象改变前深copy，或深比较以确认是否时候。这种方法的问题是深copy和深比较都是很耗性能的。</p>
<p>因此，不可变数据结构提供了更简洁和便利的跟踪对象变化的方式，需要实现shouldComponentUpdate方法。因此，如果我们的props和state使用immutable-js提供的抽象模型，我们将可以使用PureRenderMixin在pref中获得很好的推动作用。</p>
<p><strong>说明</strong></p>
<p><em>调和：state 改变导致 Virtual DOM 改变，计算真实 DOM 该如何改变的过程。</em></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/22/前端路由实现原理/" itemprop="url">
                  前端路由实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-22T18:03:30+08:00" content="2016-06-22">
              2016-06-22
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以hash形式为例，当URL的hash发生变化时，就会触发hashchange事件，此时可以在该事件的回调方法中进行不同的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Router</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">	<span class="keyword">this</span>.currentUrl = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Router.prototype = &#123;</span><br><span class="line">	route: <span class="function"><span class="keyword">function</span>(<span class="params">path, callback</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.routes[path] = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.currentUrl = location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">		<span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl]();</span><br><span class="line">	&#125;,</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.Router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="built_in">window</span>.Router.init();</span><br></pre></td></tr></table></figure>
<p>上面的Router主要提供了三个方法。</p>
<ul>
<li>init：监听浏览器URL hash事件</li>
<li>route：存储路由更新时的URL及回调函数到routes数组中，回调函数负责完成对页面的更新</li>
<li>refresh：执行当前URL对应的回调函数，更新页面</li>
</ul>
<p>使用Router的基本示例如下。</p>
<p><strong>HTML</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">'#/'</span>&gt;</span>home<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">'#/about'</span>&gt;</span> about <span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>JS</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Router.route(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'home'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Router.route(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'about'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>参考资料</strong></p>
<p><a href="https://github.com/joeyguo/blog/issues/2" target="_blank" rel="external">前端路由实现与 react-router 源码分析</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/06/ES6中改良的JS缺陷/" itemprop="url">
                  ES6中改良的JS缺陷
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-06T16:33:35+08:00" content="2016-06-06">
              2016-06-06
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="块级作用域">块级作用域</h3><p>ES5只有函数作用域，ES6提供了let和const来代替var声明变量，新的声明方式支持用大括号表示的块级作用域。</p>
<ul>
<li>防止变量在作用域外被访问</li>
<li>防止重复声明变量：ES6不允许在同一个作用域内用let或const重复声明同名变量</li>
<li>不再需要立即执行的函数表达式</li>
<li>Babel</li>
<li>循环体中的闭包不再有问题</li>
</ul>
<h3 id="词法作用域的this（通过箭头函数）">词法作用域的this（通过箭头函数）</h3><p>在ES5中，this会随着函数调用位置和调用方式改变，ES6通过箭头函数带来的词法作用域的this消除了这个问题。</p>
<p>词法作用域的this特性让变量的this总是指向词法声明时的那个对象。</p>
<h3 id="处理arguments">处理arguments</h3><p>ES5中，arguments表现的像一个数组，但不是真的数组，所以，一切数组方法如sort、slice等都用不了。</p>
<p>ES6中，可以使用一个新的特性叫做rest参数，它的形式为：<strong>…参数名（如…args）</strong>。rest参数是一个真正的数组。</p>
<h3 id="类">类</h3><p>ES6之前，JS中没有类的概念，只能把使用new关键字通过函数构造对象当作类来使用。</p>
<p>ES6带来了新的语法，与其他各种编程语言类似的语法，使得面向对象变的非常简单。</p>
<h3 id="严格模式">严格模式</h3><p>ES5中，严格模式是可选的，ES6中，许多特性都要求必须使用严格模式。</p>
<hr>
<p>参考资料：<a href="http://www.zcfy.cc/article/315?f=tt" target="_blank" rel="external">在ES6中改良的5个JavaScript缺陷</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/call-apply-bind详解/" itemprop="url">
                  call & apply & bind详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-02T09:25:03+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>call()方法的作用和apply()方法类似，只有一个区别，就是call()方法接受的是若干参数的列表，而apply()方法接受的是一个包含多个参数的数组。</p>
<h2 id="Function-prototype-call()">Function.prototype.call()</h2><p>call()方法在使用一个指定this值和若干个指定的参数值的前提下调用某个函数或方法。</p>
<h3 id="语法">语法</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span>.<span class="title">call</span></span>(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>
<h3 id="参数">参数</h3><p><strong>thisArg</strong></p>
<p>在fun函数运行时指定的this值。指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的this会指向该原始值的自动包装对象。</p>
<p><strong>arg1, arg2</strong></p>
<p>指定的参数列表。</p>
<h3 id="描述">描述</h3><p>当调用一个函数时，可以赋值一个不同的this对象。this引用当前对象，即call方法的第一个参数。</p>
<p>通过call方法，可以在一个对象上借用另一个对象上的方法，如Object.prototype.toString.call([])，就是一个Array对象借用了Object对象上的方法。</p>
<h3 id="示例">示例</h3><h4 id="使用call方法调用父构造函数">使用call方法调用父构造函数</h4><p>在一个子构造函数中，你可以通过调用父构造函数的call方法来实现继承，类似于java中的写法。下例中，使用Food和Toy构造函数创建的对象实例都会拥有在Product构造函数中添加的name属性和price属性，但category属性是各自的构造函数中定义的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.price = price;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">	Product.call(<span class="keyword">this</span>, name, price);</span><br><span class="line">	<span class="keyword">this</span>.category = <span class="string">'food'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Food.prototype = <span class="built_in">Object</span>.create(Product.prototype);</span><br><span class="line">Food.prototype.constructor = Food;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toy</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">	Product.call(<span class="keyword">this</span>, name, price);</span><br><span class="line">	<span class="keyword">this</span>.category = <span class="string">'toy'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Toy.prototype = <span class="built_in">Object</span>.create(Product.prototype);</span><br><span class="line">Toy.prototype.constructor = Toy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cheese = <span class="keyword">new</span> Food(<span class="string">'feta'</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Toy(<span class="string">'robot'</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="使用call方法调用匿名函数">使用call方法调用匿名函数</h4><p>在下例的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。这个匿名函数的主要目的是给每个元素对象添加一个print方法。这里不是必须得让数组元素作为this的值传入那个匿名函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">	&#123;</span><br><span class="line">		speicies: <span class="string">'Lions'</span>,</span><br><span class="line">		name: <span class="string">'king'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		speicies: <span class="string">'Whale'</span>,</span><br><span class="line">		name: <span class="string">'Fail'</span></span><br><span class="line">	&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = animals.length; i &lt; len; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'#'</span> + i + <span class="string">' '</span> + <span class="keyword">this</span>.species + <span class="string">' '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.print();</span><br><span class="line">	&#125;).call(anmials[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用call方法调用匿名函数并且指定上下文的this">使用call方法调用匿名函数并且指定上下文的this</h4><p>在下面的例子中，当调用greet方法时，该方法的this值会绑定到i对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> reply = [<span class="keyword">this</span>.person, <span class="string">'Is An Aesome'</span>, <span class="keyword">this</span>.role];</span><br><span class="line">	<span class="built_in">console</span>.log(reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = &#123;</span><br><span class="line">	person: <span class="string">'Douglas'</span>,</span><br><span class="line">	role: <span class="string">'JS'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">greet.call(i);</span><br></pre></td></tr></table></figure>
<h2 id="Function-prototype-apply()">Function.prototype.apply()</h2><p>apply()方法在指定this值和参数（参数以数组或类数组对象的形式存在）的情况下调用某个函数。</p>
<h3 id="语法-1">语法</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span>.<span class="title">apply</span></span>(thisArg[, argsArray])</span><br></pre></td></tr></table></figure>
<h3 id="参数-1">参数</h3><p><strong>thisArg</strong></p>
<p>在fun函数运行时指定的this值。指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null或undefined时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字、字符串、布尔值）的this会指向该原始值的自动包装对象。</p>
<p><strong>argsArray</strong></p>
<p>一个数组或者类数组对象，其中的数组元素将作为单独的参数传给fun函数。如果该参数的值为null或undefined，则表示不需要传入任何参数。从ES5开始，可以使用类数组对象。</p>
<h3 id="描述-1">描述</h3><p>在调用一个存在的函数时，你可以为其指定一个this对象。this指当前对象，也就是正在调用这个函数的对象。使用apply，你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。</p>
<p>apply可以使用数组字面量，如fun.apply(this, [‘eat’, ‘ban’])，或数组对象，如fun.apply(this, new Array(‘eat’, ‘ban’))。也可以使用arguments对象作为argsArray参数。arguments是一个函数的局部变量。它可以被用作调用对象的所有未指定的参数。这样，在使用apply函数的时候就不需要知道被调用对象的所有参数。可以使用arguments来把所有参数传递给被调用对象。</p>
<h3 id="示例-1">示例</h3><h4 id="使用apply来链接构造器">使用apply来链接构造器</h4><p>可以使用apply来给一个对象链接构造器，类似于Java。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span>(<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> oNew = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.prototype);</span><br><span class="line">	<span class="keyword">this</span>.apply(oNew, aArgs);</span><br><span class="line">	<span class="keyword">return</span> oNew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用下面的方式替换create方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span>(<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fc = <span class="keyword">this</span>, fNewConstr = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		fc.apply(<span class="keyword">this</span>, aArgs);</span><br><span class="line">	&#125;;</span><br><span class="line">	fNewConstr.prototype = fc.prototype;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> fNewConstr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用apply和内置函数">使用apply和内置函数</h4><p>apply用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> numbers = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">max</span> = Math.<span class="built_in">max</span>.apply(<span class="built_in">null</span>, numbers);</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">min</span> = Math.<span class="built_in">min</span>.apply(<span class="built_in">null</span>, numbers);</span><br></pre></td></tr></table></figure>
<p>如果数组很大，可以继续优化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minOfArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> min = <span class="literal">Infinity</span>;</span><br><span class="line">	<span class="keyword">var</span> QUANTUM = <span class="number">32768</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">var</span> submin = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, arr.slice(i, <span class="built_in">Math</span>.min(i + QUANTUM, len)));</span><br><span class="line">		min = <span class="built_in">Math</span>.min(submin, min);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> min = minOfArray(numbers);</span><br></pre></td></tr></table></figure>
<h2 id="Function-pototype-bind()">Function.pototype.bind()</h2><p>bind()方法会创建一个新函数，当这个函数被调用时，它的this值是传递给bind()的第一个参数，它的参数是 bind()的其它参数和其它原本的参数。</p>
<h3 id="语法-2">语法</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span>.<span class="title">bind</span></span>(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>
<h3 id="参数-2">参数</h3><p><strong>thisArg</strong></p>
<p>当绑定函数被调用时，该参数会作为原函数运行时的this指向。当使用new操作符调用绑定函数时，该参数无效。</p>
<p><strong>arg1, arg2, …</strong></p>
<p>当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数。</p>
<h3 id="描述-2">描述</h3><p>bind()函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体。当目标函数被调用时this值绑定到bind()的第一个参数，该参数不能被重写。绑定函数被调用时，bind()也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给模拟函数。</p>
<h3 id="示例-2">示例</h3><h4 id="创建绑定函数">创建绑定函数</h4><p>bind()函数最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">	x: <span class="number">80</span>,</span><br><span class="line">	getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">//80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line">retrieveX(); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line">boundGetX(); <span class="comment">//80</span></span><br></pre></td></tr></table></figure>
<h4 id="分离函数">分离函数</h4><p>bind()另一个用法是使一个函数拥有预设的初始参数。这些参数作为bind的第二个参数跟在this后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们的后面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var list1 = <span class="built_in">list</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">var leadingList = <span class="built_in">list</span>.bind(undefined, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">var list2 = leadingList(); <span class="comment">//[37]</span></span><br><span class="line">var list3 = leadingList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [37, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h4 id="配合setTimeout">配合setTimeout</h4><p>默认情况下，使用window.setTimeout()时，this关键字会指向window对象。当使用类的方法时，需要this引用类的实例，需要显式地把this绑定到回调函数以便继续使用实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LateBloomer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.petalCount = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">12</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LateBloomer.prototype.bloom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">window</span>.setTimeout(<span class="keyword">this</span>.declare.bind(<span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LateBloomer.prototype.declare = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'I am a beautiful flower width '</span> + <span class="keyword">this</span>.petalCount + <span class="string">' petals'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flower = <span class="keyword">new</span> LateBloomer();</span><br><span class="line">flower.bloom();</span><br></pre></td></tr></table></figure>
<h4 id="快捷调用">快捷调用</h4><p>需要为一个特定的this值的函数创建一个捷径的时候，bind()方法很好用。</p>
<p>可以用Array.prototype.slice来将一个类似于数组的对象转成一个真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">slice.apply(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p>用bind()可以使这个过程变得简单。slice是Function.prototype的call()方法的绑定函数，并且将Array.prototype的slice()方法作为this的值。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unboundSlice = <span class="keyword">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span>.<span class="title">call</span>.<span class="title">bind</span><span class="params">(unboundSlice)</span>;</span></span><br><span class="line"></span><br><span class="line">slice(arguments);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="baizn" />
          <p class="site-author-name" itemprop="name">baizn</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">52</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">102</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">baizn</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
