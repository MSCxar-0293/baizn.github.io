<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="baizn的github博客">
<meta property="og:url" content="http://baizn.github.io/page/2/index.html">
<meta property="og:site_name" content="baizn的github博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="baizn的github博客">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://baizn.github.io/page/2/"/>

  <title> baizn的github博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">baizn的github博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/28/翻译-A-B-B-A/" itemprop="url">
                  [翻译](A => B) !=> (B => A)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-28T17:24:11+08:00" content="2016-01-28">
              2016-01-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>componentWillReceiveProps的文档中指出：当props改变的时候，componentWillReceiveProps就会被调用，结果就会重新渲染。因此，一些人误以为：如果componentWillReceiveProps被调用，则props一定发生了变化。但是，这样的结论是不正确的。</p>
<p>我最喜欢的形式逻辑或数学的指导原则如下：</p>
<blockquote>
<p>A implies B does not imply B implies A</p>
</blockquote>
<p>举个栗子：“如果我吃了坏了的食物，我可能就会生病”并不能说“如果我生病了，那我就一定是吃了坏了的食物导致”。还有很多其它原因导致我不舒服的，比如办公室里的流感。类似的，有很多原因使得componentWillReceiveProps被调用，即使props并没有改变。</p>
<p>如果你不相信我说的，使用相同的props调用ReactDOM.render()三次，试着预测一下componentWillReceiveProps被调用的次数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">		console.log(<span class="symbol">'componentWillReceiveProps</span>: ' + nextProps.data.bar);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;<span class="type">Bar</span> &#123;<span class="keyword">this</span>.props.data.bar&#125;&lt;/div&gt;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = document.getElementById(<span class="symbol">'containe</span>r');</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myData = &#123;</span><br><span class="line">	bar: <span class="symbol">'drink</span>s'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> data=&#123;myData&#125; /&gt;, container);</span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> data=&#123;myData&#125; /&gt;, container);</span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> data=&#123;myData&#125; /&gt;, container);</span><br></pre></td></tr></table></figure>
<p>在本例中，答案是“2”。React调用componentWillReceiveProps两次（只有两次更新）。在这两次中，drinks的值被打印出来（props的值并没有变化）。</p>
<p>为了理解为什么会这样，我们需要想想会发生什么。在初始渲染和两次后续更新之间数据可能已经被改变了，如果代码像下面这样执行：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">var</span> myData = &#123;</span><br><span class="line">	bar: 'drinks'</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> <span class="typedef"><span class="keyword">data</span>=<span class="container">&#123;<span class="title">myData</span>&#125;</span> /&gt;, container);</span></span><br><span class="line"></span><br><span class="line"><span class="title">myData</span>.bar = 'food';</span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> <span class="typedef"><span class="keyword">data</span>=<span class="container">&#123;<span class="title">myData</span>&#125;</span> /&gt;, container);</span></span><br><span class="line"></span><br><span class="line"><span class="title">myData</span>.bar = 'noise';</span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> <span class="typedef"><span class="keyword">data</span>=<span class="container">&#123;<span class="title">myData</span>&#125;</span> /&gt;, container);</span></span><br></pre></td></tr></table></figure>
<p>数据没有改变，但React并没有办法知道。因此，React需要调用componentWillReceiveProps方法，因为组件需要新props来通知（即使新的props和旧props完全相同）。</p>
<p>你可能会认为，React可以使用很巧妙的检测机制来检测是否相等，但这种想法也有一些问题：</p>
<blockquote>
<ul>
<li><p>旧的myData和新的myData实际上是相同的物理对象（仅对象内部的值被改变）。由于采用的是triple-equals-equal，检查是否相同的时候并不会告诉我们值是否被改变。惟一可能的解决方法就是创建数据的一个深拷贝副本，接着做深比较，但这对比较大的数据结构而言过于昂贵（特别是循环）</p>
</li>
<li><p>myData对象可能包括对函数的引用，该函数通过闭包获取变量。React没有办法获取闭包内部的变量值，因此也没有办法复制和验证它们是否相等</p>
</li>
<li><p>myData可能包括父级渲染时重新实例化了的实例对象的引用，但概念上是相等的（具有相同的key和value）。深比较可以检测到这一点，除过这点又会出现新的问题，因为没有办法比较两个函数在语义上是否相同。</p>
</li>
</ul>
</blockquote>
<p>由于语言的限制，有时我们不可能实现真正意义上相等的语义。在这种情况下，React会调用componentWillReceiveProps方法（即使props可能没有改变），使得组件有机会检测新的props，并采取相应的处理。</p>
<p>这样一来，实现componentWillReceiveProps方法时候要确保props不能被修改。如果你想在props被改变后执行一些操作（如网络请求），你的componentWillReceiveProps代码需要检查props是否真正的被改变了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/28/翻译-React组件API/" itemprop="url">
                  [翻译]React组件API
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-28T14:47:43+08:00" content="2016-01-28">
              2016-01-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="React-Component">React.Component</h3><p>当渲染的时候在React内部创建一个React组件的实例，这些实例在随后的渲染中都是可以被重复使用的，并且可以在组件的方法中作为this被访问。这是唯一可以处理在React外部的React组件中存储ReactDom.render的返回值的方式，其它组件内部，则可以使用refs的到相同的结果。</p>
<h3 id="setState">setState</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(</span><br><span class="line">	<span class="keyword">function</span> | <span class="keyword">object</span> nextState,</span><br><span class="line">	[<span class="keyword">function</span> callback]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>对nextState执行浅合并到当前state，该方法是用于处理事件处理程序和服务请求回调触发UI更新的主要方法。</p>
<p>第一个参数可以是对象（含0个或多个待更新的key）或返回一个包含了更新后的所有key的函数（state和props）。</p>
<p>简单的对象参数示例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">setState</span>(<span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">myName</span>:<span class="value"> <span class="string">'name'</span></span><br><span class="line"></span></span></span>&#125;);</span><br></pre></td></tr></table></figure>
<p>设置任何values之前，当我们想参考以前的state和props的值来进行原子更新时候可以通过一个签名function(state, props)来实现。比如我们想增加一个状态值。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">setState</span>(<span class="function">function</span>(previousState, currentProps) &#123;</span><br><span class="line">	<span class="tag">return</span> &#123;</span><br><span class="line">		<span class="attribute">myNum</span>: previousState.num + <span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第二个参数是当setState执行成功一次并且组件被重新渲染时候的一个回调函数。</p>
<blockquote>
<p>不要直接修改this.state的值，通过调用setState来更新state的值。应该将this.state视为不可变的。</p>
<p>setState()不会立即修改this.state，而是新增一个过渡的挂起状态。调用setState()方法后访问this.state时，可以潜在的返回一个现有的值。</p>
<p>不能保证调用setState()是同步进行的，为了提升性能，调用setState可能是分批进行的。</p>
<p>setState()总会触发重现渲染，除非渲染逻辑是在shouldComponentUpdate()中实现。如果正在使用可变的对象，并且渲染逻辑没有在shouldComponentUpdate()中实现，调用setState()，只有当新的state和前一个state不同才渲染，从而避免了不必要的渲染。</p>
</blockquote>
<h3 id="replaceState">replaceState</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> replaceState(</span><br><span class="line">	<span class="keyword">object</span> nextState,</span><br><span class="line">	[<span class="keyword">function</span> callback]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>类似setState()方法，不同的是删除了不在nextState中的所有预先存在的state。</p>
<blockquote>
<p>该方法不适用于ES6类组件扩展React.Component,在以后的版本中可能会被删除。</p>
</blockquote>
<h3 id="forceUpdate">forceUpdate</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forceUpdate</span><span class="params">(</span><br><span class="line">	[function callback]</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>默认情况下，当组件的state或props改变的时候，组件就会重新渲染。但是，如果这些变化很含蓄（对象内部嵌套很深的数据改变，对象本身并不改变）或render()方法依赖其它数据时候，我们可以告诉React需要通过forceUpdate()方法重新渲染。</p>
<p>调用forceUpdate()方法会引起组件重新渲染，会跳过shouldComponentUpdate()方法。这将触发子组件的正常的生命周期方法，包括每个子组件的shouldComponentUpdate()方法。React仍然只更新DOM标记了改变的部分。</p>
<p>通常情况下应该避免使用forceUpdate()方法，在render()方法中只从this.props和this.state获取数据。这样可以确保组件的“纯”，应用程序也会更简单，更高效。</p>
<h3 id="getDOMNode">getDOMNode</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMElement <span class="function"><span class="title">getDOMNode</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果组件已经被装载到DOM中，该方法将会返回相应的原生浏览器的DOM元素。这个方法用来读取DOM的值，比如表单字段值，并进行DOM测试。当render返回null或false时，this.getDOMNode()返回null。</p>
<blockquote>
<p>getDOMNode()方法已被弃用，已替换为ReactDOM.findDomNode()。</p>
<p>该方法不适用于ES6类组件扩展React.Component，可能会在后续版本中删除。</p>
</blockquote>
<h3 id="isMounted">isMounted</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="function"><span class="title">isMounted</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果组件被渲染到DOM中，isMounted()返回true，否则返回false。可以使用此方法来保证对setState()或forceUpdate()的异步调用。</p>
<blockquote>
<p>该方法不适用于继承React.Component的ES6 class组件，可能会在后续版本中删除。</p>
</blockquote>
<h3 id="setProps">setProps</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setProps(</span><br><span class="line">	<span class="keyword">object</span> nextProps,</span><br><span class="line">	[<span class="keyword">function</span> callback]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当与外部JavaScript应用程序继承时，可能需要一个信号的改变来使用ReactDOM.render()渲染一个React组件。</p>
<p>在根级组件中调用setProps()方法将会改变其属性，并触发重新渲染。此外，也可以在setProps()只执行一次和组件重新渲染完成后提供一个回调函数。</p>
<blockquote>
<p>该方法已被弃用，并将很快被删除。该方法不适用于ES6类组件扩展React.Component。通过使用新的props再次调用ReactDOM.render()来代替setProps()方法。其它注意事项，可参考<a href="http://baizn.github.io/2016/01/26/React%E9%A1%B6%E5%B1%82API/">React Top Level API</a>。</p>
<p>如果可能的话，在同一个节点上再次调用ReactDOM.render()反而是更可取的方式。这往往使更新更容易推理（这两种方法之间并没有显著的性能差异）。</p>
<p>该方法只能在根级组件调用，即它是唯一可以直接将组件传递到ReactDOM.render()的方法，并不包括其子组件。如果你倾向于在子组件上使用setProps()，应该改为当子组件创建时在其render()中使用更灵活的更新和传递新的props到子组件。</p>
</blockquote>
<h3 id="replaceProps">replaceProps</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> replaceProps(</span><br><span class="line">	<span class="keyword">object</span> nextProps,</span><br><span class="line">	[<span class="keyword">function</span> callback]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>类似setProps()，但删除了预定存在的props，而不是合并两个对象。</p>
<blockquote>
<p>该方法已被弃用，并将很快被删除。</p>
<p>该方法不适用于继承React.Component的ES6 class组件。通过使用新的props再次调用ReactDOM.render()来代替replaceProps。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/28/翻译-React组件状态及生命周期/" itemprop="url">
                  [翻译]React组件状态及生命周期
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-28T14:46:33+08:00" content="2016-01-28">
              2016-01-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="组件规范">组件规范</h2><p>当调用React.createClass()方法创建组件的时候，我们应该提供一个包含了render方法的规范的对象，并且可以包含其它生命周期方法的描述。</p>
<blockquote>
<p>另外，也可以使用普通的JS类来定义组件。这些类可以实现大多数相同的方法，但也有一些差异。有关这些差异的详细信息，请参考<a href="http://baizn.github.io/2016/01/14/%E4%BD%BF%E7%94%A8ES6%E5%BC%80%E5%8F%91React/">ES6类的文档</a>。</p>
</blockquote>
<h3 id="render">render</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactElement <span class="function"><span class="title">render</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>render()方法是必须的。</p>
<p>当调用的时候，会检测this.props和this.state，返回一个单子级组件。改子级组件可以是虚拟的本地DOM组件（如\<div>或React.DOM.div()），也可以是自定义的复合组件。</div></p>
<p>也可以返回null或false来表明不需要渲染任何东西。实际上，React通过渲染一个\<noscript>标签来处理当前的差异检测逻辑。当返回null或false的时候，React.findDOMNode(this)将返回null。</noscript></p>
<p>render()函数应该是纯函数，即该函数不修改组件的state，每次调用都返回相同的结果，不读写DOM信息，也不和浏览器交互（如通过使用setTimeout）。如果需要和浏览器交互，在componentDidMount()方法中或其它生命周期方法中来做。保持render()函数为纯函数，可以使得服务端渲染更加切实可行，也使得组件更容易被理解。</p>
<h3 id="getInitialState">getInitialState</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span> <span class="function"><span class="title">getInitialState</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在组件挂载之前调用一次。返回值将会作为this.state的初始值。</p>
<h3 id="getDefaultProps">getDefaultProps</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span> <span class="function"><span class="title">getDefaultProps</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在组件类创建的时候调用一次，然后返回值被缓存下来。如果父组件没有指定props中的某个健，则此处返回的对象中的相应属性会合并到this.props（使用in检测属性）。</p>
<p>该方法在任何实例创建之前调用，因此不能依赖于this.props。另外，getDefaultProps()返回的任何复杂对象将会在实例间共享，而不是每个实例拥有一份拷贝。</p>
<h3 id="propTypes">propTypes</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span> propTypes</span><br></pre></td></tr></table></figure>
<p>propTypes对象允许验证传入到组件的props。更多关于propTypes的信息，参考<a href="http://baizn.github.io/2016/01/27/React%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%BB%84%E4%BB%B6/">React可复用组件</a> 。</p>
<h3 id="mixins">mixins</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span> mixins</span><br></pre></td></tr></table></figure>
<p>mixin数组允许使用混合来在多个组件之间共享行为。更多关于mixin的信息，参考<a href="http://baizn.github.io/2016/01/27/React%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%BB%84%E4%BB%B6/">React可复用组件</a> 。</p>
<h3 id="statics">statics</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span> statics</span><br></pre></td></tr></table></figure>
<p>statics对象允许定义静态方法，这些静态方法可以在组件类上调用。如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloReact = React.createClass(&#123;</span><br><span class="line">	statics: &#123;</span><br><span class="line">		customMethod: <span class="function"><span class="keyword">function</span><span class="params">(foo)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> foo === <span class="string">'bar'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">HelloReact.customMethod(<span class="string">'bar'</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在这个块里面定义的方法都试静态的，意味着你可以在任何组件实例创建之前调用它们，这些方法不能获取组件的props和state。如果想在静态方法中检测props的值，在调用处把props作为参数传入到静态方法。</p>
<h3 id="displayName">displayName</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> displayName</span><br></pre></td></tr></table></figure>
<p>displayName字符串用于输出调试信息，JSX自动设置该值。</p>
<h2 id="生命周期方法">生命周期方法</h2><p>许多方法在组件生命周期中某个确定的时间点执行。</p>
<h3 id="挂载(Mounting)：componentWillMount">挂载(Mounting)：componentWillMount</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentWillMount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>服务端和客户端都只调用一次，在初始化渲染执行之前立即调用。如果在这个方法内调用setState，render()将会感知到更新后的state，将会执行一次，尽管state改变了。</p>
<h3 id="挂载(Mounting)：componentDidMount">挂载(Mounting)：componentDidMount</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在初始化渲染执行之后立即调用一次，仅客户端有效（服务端不会调用）。在生命周期的这个时间点上，可以访问子组件的任何refs（如访问底层DOM）。子组件的componentDidMount()方法在父组件之前调用。</p>
<p>如果想和其它JS框架集成，使用setTimeout或setInterval来设置定时器，或发送AJAX请求，可以在该方法中执行这些操作。</p>
<h3 id="更新(Updating)：componentWillReceiveProps">更新(Updating)：componentWillReceiveProps</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> componentWillReceiveProps(</span><br><span class="line">	<span class="keyword">object</span> nextProps</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在组件接收到新的props时候调用。在初始化渲染时候，该方法不会被调用。</p>
<p>用此函数可以作为React在prop传入之后，render()方法被调用之前更新state的机会。老得props可以通过this.props获取到。在该函数中调用this.setState()将不会引起第二次渲染。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">componentWillReceiveProps</span>: <span class="tag">function</span>(nextProps) &#123;</span><br><span class="line">	<span class="tag">this</span><span class="class">.setState</span>(&#123;</span><br><span class="line">		<span class="attribute">likesIncreasing</span>: nextProps.likeCount &gt; this.props.likeCount</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个常见的错误是生命周期方法在执行过程中假设props被改变了。要理解这样为什么是无效的，请参考<a href="http://baizn.github.io/2016/01/28/%E7%BF%BB%E8%AF%91-A-B-B-A/">A implies B does not imply B implies A</a>。</p>
<p>没有类似的componentWillReceiveState方法。传入的prop可能会导致state改变，反之则不然。如果需要在state改变的时候执行一些操作，请使用componentWillUpdate。</p>
</blockquote>
<h3 id="更新(Updating)：shouleComponentUpdate">更新(Updating)：shouleComponentUpdate</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean shouldComponentUpdate(</span><br><span class="line">	<span class="tag">object</span> nextProps, <span class="tag">object</span> nextState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在接收到新的props或state，将要渲染之前调用。该方法在初始化渲染的时候不会调用，在使用forceUpdate方法时候也不会被调用。</p>
<p>如果确定新的props或state不会导致组件更新，则此处应该返回false。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate: <span class="function"><span class="keyword">function</span><span class="params">(nextProps, nextState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> nextProps.id !== <span class="keyword">this</span>.props.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果shouldComponentUpdate返回false，则render()将不会执行，直到下一次state改变。另外，componentWillUpdate和componentDidUpdate也不会被调用。</p>
<p>默认情况下，shouldComponentUpdate总会返回true，在state改变的时候可以避免一些细微的BUG，但如果总是小心地把state当做不可变的，在render()中只从props和state读取值，此时可以覆盖shouldComponentUpdate方法，实现新旧props和state的比对逻辑。</p>
<p>如果性能是个瓶颈，尤其是有几十个甚至上百个组件的时候，使用shouldComponentUpdate可以提升应用的性能。</p>
<h3 id="更新(Updating)：componentWillUpdate">更新(Updating)：componentWillUpdate</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate(</span><br><span class="line">	<span class="tag">object</span> nextProps, <span class="tag">object</span> nextState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在接收到新的props或state之前立即调用，在初始化渲染的时候该方法不会被调用。</p>
<p>使用该方法做一些更新之前的准备工作。</p>
<blockquote>
<p>在该方法中不能使用this.setState()。如果需要更新state来响应某个prop的改变，请使用componentWillReceiveProps方法。</p>
</blockquote>
<h3 id="更新(Updating)：componentDidUpdate">更新(Updating)：componentDidUpdate</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void componentDidUpdate(</span><br><span class="line">	<span class="tag">object</span> prevProps, <span class="tag">object</span> prevState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在组件的更新已经同步到DOM中之后立即被调用，该方法不会在初始化渲染的时候调用。</p>
<p>使用该方法可以在组件更新后操作DOM元素。</p>
<h3 id="卸载(Unmounting)：componentWillUnmount">卸载(Unmounting)：componentWillUnmount</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentWillUnmount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>组件从DOM中卸载之前立即被调用。</p>
<p>可以在该方法中执行任何必须的清理工作，如清除定时器或清除在componentDidMount中创建的任何DOM元素。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/28/翻译-React可复用组件/" itemprop="url">
                  [翻译]React可复用组件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-28T14:45:28+08:00" content="2016-01-28">
              2016-01-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>设计接口的时候，把常用的设计元素（如按钮，表单，布局组件等）拆成接口良好的定义的可复用的组件。这样，下次开发相同界面时就可以写更少的代码，也意味着更高的开发效率，更少的BUG和更少的程序体积。</p>
<h3 id="Prop验证">Prop验证</h3><p>随着应用的不断变大，保证组件被正确使用变的非常有用。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">React.createClass(&#123;</span><br><span class="line">	propTypes: &#123;</span><br><span class="line">		<span class="comment">//可以声明prop为指定的JS基本类型，默认情况下，这些prop都是可选的</span></span><br><span class="line">		optionalArray: React.PropTypes.<span class="keyword">array</span>,</span><br><span class="line">		optionalBool: React.PropTypes.<span class="keyword">bool</span>,</span><br><span class="line">		optionalFunc: React.PropTypes.func,</span><br><span class="line">		optionalNumber: React.PropTypes.number,</span><br><span class="line">		optionalObject: React.PropTypes.object,</span><br><span class="line">		optionalString: React.PropTypes.string,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//所有类型都可以被渲染，numbers，string，elements或包括这些类型的数组</span></span><br><span class="line">		optionalNode: React.PropTypes.node,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//react element</span></span><br><span class="line">		optionalElement: React.PropTypes.element,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//使用JS的instanceof操作符，可以声明一个class实例的prop</span></span><br><span class="line">		optionalMessage: React.PropTypes.<span class="keyword">instanceOf</span>(Message),</span><br><span class="line"></span><br><span class="line">		<span class="comment">//可以限制props的值只在一个枚举中取值</span></span><br><span class="line">		optionalEnum: React.PropTypes.oneOf([<span class="string">'bbb'</span>, <span class="string">'aaa'</span>]),</span><br><span class="line"></span><br><span class="line">		<span class="comment">//指定多个对象类型中的一个</span></span><br><span class="line">		optionalUnion: React.PropTypes.oneOfType([</span><br><span class="line">			React.PropTypes.string,</span><br><span class="line">			React.PropTypes.number,</span><br><span class="line">			React.PropTypes.<span class="keyword">instanceOf</span>(Message)</span><br><span class="line">		]),</span><br><span class="line"></span><br><span class="line">		<span class="comment">//指定类型的属性构成的对象</span></span><br><span class="line">		optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),</span><br><span class="line"></span><br><span class="line">		<span class="comment">//特定对象参数</span></span><br><span class="line">		optionalObjectWithShape: React.PropTypes.shape(&#123;</span><br><span class="line">			color: React.PropTypes.string,</span><br><span class="line">			fontSize: React.PropTypes.number</span><br><span class="line">		&#125;),</span><br><span class="line"></span><br><span class="line">		<span class="comment">//为任意类型添加isRequired时，保证其props不为空</span></span><br><span class="line">		requiredFunc: React.PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//非空的任意数据类型</span></span><br><span class="line">		requiredAny: React.PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//自定义的验证器，如果验证失败则返回一个Error对象，不要使用console.warn或抛异常，因为会导致oneOfType失效</span></span><br><span class="line">		customProp: <span class="function"><span class="keyword">function</span><span class="params">(props, propName, componentName)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!/matchme/.test(props[propName])) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Error(<span class="string">'Validation failed!'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Signle_Child">Signle Child</h3><p>使用React.PropTypes.element，你只能指定一个子元素作为children传递给组件。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloReact = React.createClass(&#123;</span><br><span class="line">	propTypes: &#123;</span><br><span class="line">		children: React.PropTypes.element.isRequired</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&#123;<span class="comment">/*必选是一个元素，否则会出现警告*/</span>&#125;</span><br><span class="line">				&#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="默认Props值">默认Props值</h3><p>React支持以声明的方式来定义props的默认值。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentWithDefaultProps = React.createClass(&#123;</span><br><span class="line">	getDefaultProps: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			value: <span class="string">'default value'</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当父级没有传入props时，getDefaultProps()可以保证this.props.value有默认值，getDefaultProps()的结果会被缓存。可以直接使用props，而不必手动编写一些重复或无意义的代码。</p>
<h3 id="传递Props的小技巧">传递Props的小技巧</h3><p>有一些常用的React组件只是对HTML做简单扩展。通常，希望少写点代码把传入组件的props复制到对应的HTML元素上，可以使用JSX的spread语法：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CheckLink = React.createClass(&#123;</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		&#123;<span class="comment">/*会把CheckLink所有的props复制到&lt;a&gt;标签上面*/</span>&#125;</span><br><span class="line">		<span class="keyword">return</span> &lt;a &#123;...<span class="keyword">this</span>.props&#125;&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;/a&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">	&lt;CheckLink href=<span class="string">'/checked.html'</span>&gt;</span><br><span class="line">		Click <span class="keyword">here</span></span><br><span class="line">	&lt;/CheckLink&gt;,</span><br><span class="line">	document.querySelector(<span class="string">'#container'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="Mixins">Mixins</h3><p>组件是React里复用代码的最佳方式，但有时一些复杂的组件间也需要共用一些功能。有时会被称为跨切面关注点。React使用mixins来解决此类问题。</p>
<p>一个通用的场景是：一个组件需要定期更新。用setInterval()很容易实现，但当不需要它的时候取消定时器来节约内存是非常重要的。React提供了<a href="http://baizn.github.io/2016/01/28/React%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期方法</a>来告知组件创建或销毁的时间。下面实现一个简单的mixin，使用setInterval()并保证在组件销毁时清理定时器。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SetIntervalMixin = &#123;</span><br><span class="line">	componentWillMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.intervals = [];</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	setInterval: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.intervals.push(setInterval.apply(<span class="literal">null</span>, arguments));</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	componentWillUnmount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.intervals.map(clearInterval);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TickTock = React.createClass(&#123;</span><br><span class="line">	mixins: [SetIntervalMixin], <span class="comment">//引用mixin</span></span><br><span class="line">	getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			second: <span class="number">0</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setInterval(<span class="keyword">this</span>.tick, <span class="number">1000</span>); <span class="comment">//调用mixin的setInterval方法</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	tick: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">			second: <span class="keyword">this</span>.state.second + <span class="number">1</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;p&gt;React has been running <span class="keyword">for</span> &#123;<span class="keyword">this</span>.state.second&#125; seconds.&lt;/p&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">	&lt;TickTock /&gt;,</span><br><span class="line">	document.querySelector(<span class="string">'#container'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>关于mixin值得一提的优点是，如果一个组件使用了多个mixin，并且有多个mixin定义了同样的生命周期方法（多个mixin都需要在组件销毁时做资源清理操作），所有这些生命周期方法都保证会被执行到。方法执行的顺序是：首先按mixin引入顺序执行mixin里的方法，最后执行组件内定义的方法。</p>
<h3 id="ES6_Classes">ES6 Classes</h3><p>你也可以把React组件作为一个普通的JS类来定义。如使用ES6的class语法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;<span class="type">Hello</span> &#123;<span class="keyword">this</span>.props.name&#125;&lt;/div&gt;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">HelloReact</span> name=<span class="symbol">'reac</span>t' /&gt;, document.body);</span><br></pre></td></tr></table></figure>
<p>该API类似于没有getInitialState方法的React.createClass。不再单独提供一个getInitialState方法，需要在构造方法中设置state属性。</p>
<p>另一个区别是propTypes和defaultProps作为属性被定义在构造方法中而不是class内部。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		<span class="keyword">super</span>(props);</span><br><span class="line">		<span class="keyword">this</span>.state = &#123;</span><br><span class="line">			count: props.initialCount</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tick() &#123;</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">			count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div onClick=&#123;<span class="keyword">this</span>.tick.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">				<span class="type">Clicks</span>: &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Counter</span>.propTypes = &#123;</span><br><span class="line">	initialCount: <span class="type">React</span>.<span class="type">PropTypes</span>.number</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Counter</span>.defaultProps = &#123;</span><br><span class="line">	initialCount: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="没有自动绑定">没有自动绑定</h3><p>如普通的ES6类，这些方法都遵循相同的语义，这意味着它们不会自动绑定到这个实例上面。你必须显式地使用bind(this)或箭头函数 =&gt;。</p>
<h3 id="没有Mixin">没有Mixin</h3><p>可惜的是ES6不再支持任何Mixin。因此，当你使用ES6的classes来开发React应用时不再支持mixins。相反，我们正在努力使得支持类似的用例更容易而不是混入mixins。</p>
<h3 id="无状态的Functions">无状态的Functions</h3><p>你可以像定义一个普通的JS函数那样定义React类。如使用无状态的函数语法。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloReact</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;HelloReact name=<span class="string">'react'</span> /&gt;, document.body);</span><br></pre></td></tr></table></figure>
<p>或使用ES6的箭头函数。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var HelloReact = <span class="function"><span class="params">(props)</span> =&gt;</span> &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;HelloReact name=<span class="string">'react'</span> /&gt;, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p>这个简单的组件API适用于带有props的纯函数的组件。这些组件不能有内部状态，没有后续实例，并且没有组件生命周期方法。它们是根据输入转化的纯函数，无副作用。但是，仍然可以指定propTypes和defaultProps，然后将其设置为该函数的属性。就类似于使用ES6类时那样设置。</p>
<blockquote>
<p>因为无状态的函数没有后续的实例，因此不能在无状态函数的组件上附加ref属性。通常情况下，这并不是什么问题，因此无状态的函数不提供必须的API。没有必须的API，对一个实例也没有太多的操作。如果用户想在无状态的函数组件中找DOM节点，那么无状态的组件必须包裹在一个有状态组件中（如ES6的类组件），并且在包裹的组件上附加ref属性。</p>
</blockquote>
<p>理想状态下，大多数的组件应该都是无状态的函数，因为在React核心内部，这些无状态的函数组件会流动更快。这只是在条件允许的情况下的一种推荐模式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/28/翻译-React顶层API/" itemprop="url">
                  [翻译]React顶层API
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-28T14:41:27+08:00" content="2016-01-28">
              2016-01-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="React">React</h2><p>React是React库的入口。如果使用的是预编译包，则React是全局的；如果使用的CommonJS模块，则可以使用require()函数引入React。</p>
<h3 id="React-Component">React.Component</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br></pre></td></tr></table></figure>
<p>当使用ES6的class定义React组件的时候，React Component是所有组件的基类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;hello &#123;<span class="keyword">this</span>.props.name&#125;&lt;/div&gt;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">HelloReact</span> name=<span class="symbol">'reac</span>t'/&gt;, document.body);</span><br></pre></td></tr></table></figure>
<h3 id="React-createClass">React.createClass</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReactClass <span class="title">createClass</span>(<span class="params"><span class="keyword">object</span> specification</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>创建一个组件类，并作出定义。组件实现了render()方法，该方法返回一个子级。该子级可能包含很深的子级结构。组件与标准原型的不同之处在于，不需要使用new来实例化。组件是一种很方便的封装，可以在后台创建实例（通过new）。</p>
<p>更多关于定义组件对象的信息，参考<a href="http://baizn.github.io/2016/01/11/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/">React组件生命周期</a>。</p>
<h3 id="React-createElement">React.createElement</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReactElement</span> createElement(</span><br><span class="line">	string/<span class="type">ReactClass</span> <span class="class"><span class="keyword">type</span>,</span><br><span class="line"></span>	[<span class="class"><span class="keyword">object</span> <span class="title">props</span>],</span><br><span class="line"></span>	[children ...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>根据指定的类型，创建并返回一个ReactElement。type参数可以是一个html标签名字符串（如div，span等），或者是ReactClass（通过React.createClass创建）。</p>
<h3 id="React-cloneElement">React.cloneElement</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactElement <span class="function">cloneElement</span>(</span><br><span class="line">	ReactElement element,</span><br><span class="line">	<span class="attr_selector">[object props]</span>,</span><br><span class="line">	<span class="attr_selector">[children ...]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>克隆element元素并返回一个新的ReactElement。得到的新ReactElement的props是原始元素的props和新props的浅合并的结果。新的children将替换现有的children。不同于React.addons.cloneWithProps，原始元素的key和ref都将被保留下来。合并props时没有任何特殊的行为，参考<a href="">v0.13.RC2博客</a>了解更多信息。</p>
<h3 id="React-createFactory">React.createFactory</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factoryFunction createFactory(</span><br><span class="line">	<span class="type">string</span>/ReactClass <span class="operator">type</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>返回一个生成指定类型ReactElements的函数，比如React.createElement，type参数可以是一个html标签名的字符串（如div，span等）或是ReactClass。</p>
<h3 id="React-isValidElement">React.isValidElement</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="function"><span class="title">isValidElement</span><span class="params">(* object)</span></span></span><br></pre></td></tr></table></figure>
<p>验证参数对象是否为ReactElement类型。</p>
<h3 id="React-DOM">React.DOM</h3><p>React.DOM利用React.createElement为DOM组件进行了封装，只能使用于不使用JSX的情况下。比如：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.DOM.<span class="keyword">div</span>(<span class="keyword">null</span>, <span class="string">'hello react'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="React-PropTypes">React.PropTypes</h3><p>React.PropTypes所包括的类型用于组件的propTypes对象，目的是为了监测被传递到子组件中的props类型。有关propTypes的更多信息请参考<a href="http://baizn.github.io/2016/01/27/React%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%BB%84%E4%BB%B6/">可重用组件</a>。</p>
<h3 id="React-Children">React.Children</h3><p>React.Children提供了处理this.props.children不透明数据结构的实用工具方法。</p>
<h4 id="React-Children-map">React.Children.map</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array React<span class="class">.Children</span><span class="class">.map</span>(<span class="tag">object</span> children, function fn [, <span class="tag">object</span> thisArg])</span><br></pre></td></tr></table></figure>
<p>在所包含的children中的每一个直接child上为thisArg调用fn函数。如果children是嵌套对象或数组则会遍历：fn函数不会被传递到容器对象中；如果children是null或undefined将返回null或undefined，而不是一个数组。</p>
<h4 id="React-Children-forEach">React.Children.forEach</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React<span class="class">.Children</span><span class="class">.forEach</span>(<span class="tag">object</span> children, function fn [, <span class="tag">object</span> thisArg])</span><br></pre></td></tr></table></figure>
<p>类似React.Children.map，但不会返回数组。</p>
<h4 id="React-Children-count">React.Children.count</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number React<span class="class">.Children</span><span class="class">.count</span>(<span class="tag">object</span> children)</span><br></pre></td></tr></table></figure>
<p>返回children中的组件总数，等于map或forEach的回调函数被调用的次数。</p>
<h4 id="React-Children-only">React.Children.only</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span> React<span class="class">.Children</span><span class="class">.only</span>(<span class="tag">object</span> children)</span><br></pre></td></tr></table></figure>
<p>返回children中惟一的child，否则抛出错误。</p>
<h4 id="React-Children-toArray">React.Children.toArray</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array React<span class="class">.Children</span><span class="class">.toArray</span>(<span class="tag">object</span> children)</span><br></pre></td></tr></table></figure>
<p>返回将children的不透明数据结构转换为以每个child的key所组成的数组。如果你想在render方法中操控children的集合，特别是你希望在它向下传递之前重新排列或裁剪this.props.children时很有用。</p>
<h2 id="ReactDOM">ReactDOM</h2><p>react-dom包在应用程序的顶层提供了一些特定的DOM方法，如果需要，可以作为备用途径在React模型外部使用，大部分的组件不应该使用这个模块。</p>
<h3 id="ReactDOM-render">ReactDOM.render</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent render(</span><br><span class="line">	ReactElement <span class="keyword">element</span>,</span><br><span class="line">	DOMElement container,</span><br><span class="line">	[<span class="function"><span class="keyword">function</span> <span class="title">callbacl</span>]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>渲染一个ReactElement到DOM提供的container上，并返回一个组件的引用（返回null或无状态的组件）。</p>
<p>如果ReactElement已经被渲染到container中，只有DOM上发生变化时候才会重新渲染，以反映React组件的最新状态。</p>
<p>如果提供了可选的回调函数，它会在组件渲染或更新完成后执行。</p>
<blockquote>
<p>ReactDOM.render()控制你传递给容器节点的内容。当第一次调用时候，容器中任何已有的DOM元素都会被替换掉。以后的调用都会使用React DOM的diff算法进行高效的更新。</p>
<p>ReactDOM.render()不修改容器节点（只修改容器的子节点），将来可能会是在现有的DOM节点中插入组件而不覆盖已有的子组件。</p>
</blockquote>
<h3 id="ReactDOM-unmountComponentAtNode">ReactDOM.unmountComponentAtNode</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="function"><span class="title">unmountComponentAtNode</span><span class="params">(DOMElement container)</span></span></span><br></pre></td></tr></table></figure>
<p>从DOM中删除已经加载了的React组件，并清理它的事件处理程序和state。如果在容器中没有加载任何组件，调用此方法什么都不做；如果组件被卸载了则返回ture，如果没有组件卸载则返回false。</p>
<h3 id="ReactDOM-findDOMNode">ReactDOM.findDOMNode</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMElement <span class="function"><span class="title">findDOMNode</span><span class="params">(ReactComponent component)</span></span></span><br></pre></td></tr></table></figure>
<p>如果该组件已经被加载到DOM中，则返回对应的原生浏览器DOM元素。这个方法用于读取DOM的值，比如表单字段，并进行DOM验证。大多数情况下，可以在DOM节点上附加一个ref属性，避免所有情况下都使用findDOMNode。当render返回null或false时，findDOMNode返回null。</p>
<blockquote>
<p>findDOMNode()是用于访问底层DOM节点的备用通道，大多数情况下，不鼓励使用该方法，因为它破坏了组件的抽象化。</p>
<p>findDOMNode()只适用于已经加载的组件（即已放置在DOM中的组件）。如果你试图在还没有被加载的组件上（比如在一个还没有被创建的组件的render()中调用findDOMNode()，）调用该方法将会抛出一个异常。</p>
<p>findDOMNode()不能被用于无状态的组件上。</p>
</blockquote>
<h2 id="ReactDOMServer">ReactDOMServer</h2><p>react-dom/server包允许你在服务端渲染组件。</p>
<h3 id="ReactDOMServer-renderToString">ReactDOMServer.renderToString</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string <span class="function"><span class="title">renderToString</span><span class="params">(ReactElement element)</span></span></span><br></pre></td></tr></table></figure>
<p>渲染一个ReactElement为原始的HTML，这应该只用于服务端。React将返回一个HTML字符串。你可以使用该方法在服务器上生成HTML，然后将这些标记发送给客户端，这样可以加快页面首次加载速度，并让搜索引擎能获取到页面从而达到搜索引擎优化的目的。</p>
<p>如果在一个已有服务端渲染标记的节点上调用ReactDOM.render()，React将会保留该节点，并且仅绑定事件处理器，保证有一个高效的首屏加载体验。</p>
<h3 id="ReactDOMServer-renderToStaticMarkup">ReactDOMServer.renderToStaticMarkup</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string <span class="function"><span class="title">renderToStaticMarkup</span><span class="params">(ReactElement element)</span></span></span><br></pre></td></tr></table></figure>
<p>类似renderToString，除了不会产生额外的DOM属性，如data-react-id，因为这些属性仅在React内部使用。如果想用React做一个简单的静态页面生成器，这将很有用，因为丢掉了额外的属性，节省了很多子节。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/14/使用ES6开发React/" itemprop="url">
                  使用ES6开发React
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-14T17:19:27+08:00" content="2016-01-14">
              2016-01-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用ES6开发React">使用ES6开发React</h2><p>开发React项目使用ES6的语法会带来很多便利。</p>
<h3 id="Class">Class</h3><p>使用ES6语法，定义React组件时候使用class关键字代替ES5中的React.createClass方法，可以通过继承React.Component定义一个React组件。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;h2&gt;<span class="type">Hello</span> <span class="type">React</span>!&lt;/h2&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在定义React组件的时候，你有多了一种选择，ES5或ES6写法</p>
<p>对于同一个组件，不同写法如下。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5定义React组件</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">MyReact</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">	handleChange: function() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;,</span><br><span class="line">	render: function() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6定义React组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	handleChange() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过ES6语法定义React组件，我们可以少写两个括号，一个后分号，省略了方法声明时的冒号及function关键字等。</p>
<p>当使用class定义React组件时，所有的生命周期方法都可以使用，class的constructor方法可以替代componentWillMount方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5定义React组件</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">MyReact</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">	componentWillMount: function() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6定义React组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		<span class="keyword">super</span>(props);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性初始化">属性初始化</h3><p>在ES6的class里面，prop types和props的默认值是作为其静态属性的。prop types，默认props及组件的初始state可以使用ES7的属性初始化（property initializers）定义。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">MyReact</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">	getDefaultProps: function() &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			name: <span class="symbol">'Reac</span>t'</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	getInitialState: function() &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			loading: <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	propTypes: &#123;</span><br><span class="line">		name: <span class="type">React</span>.<span class="type">PropTypes</span>.string.isRequired,</span><br><span class="line">		loading: <span class="type">React</span>.<span class="type">PropTypes</span>.bool.isRequired</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	static defaultProps = &#123;</span><br><span class="line">		name: <span class="symbol">'Reac</span>t'</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static propTypes = &#123;</span><br><span class="line">		name: <span class="type">React</span>.<span class="type">PropTypes</span>.string.isRequired,</span><br><span class="line">		loading: <span class="type">React</span>.<span class="type">PropTypes</span>.string.isRequired</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	state = &#123;</span><br><span class="line">		loading: <span class="keyword">this</span>.props.name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES7的初始化操作是在构造函数中，即引用的是类的构造函数中的实例。因此state的初始值仍可以依赖this.props。不在需要在getter方法中定义默认props和state对象了。</p>
<h3 id="箭头函数">箭头函数</h3><p>使用React.createClass方法定义组件的时候，组件的实例方法完成一些额外的绑定工作，在它们内部，this关键字引用的组件实例会有问题。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this自动绑定</span></span><br><span class="line"><span class="keyword">var</span> MyReact = React.crateClass(&#123;</span><br><span class="line">	handleChange: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//this引用的组件实例</span></span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">			loading: <span class="literal">true</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>不使用React.createClass方法，使用ES6的class语法定义组件时候，当需要时候我们可以手动绑定实例方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要时候手动绑定</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		<span class="keyword">super</span>(props);</span><br><span class="line">		<span class="comment">//onChange与组件实例手动绑定</span></span><br><span class="line">		<span class="keyword">this</span>.onChange = <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	onChange(state) &#123;</span><br><span class="line">		<span class="comment">//this引用的是组件实例</span></span><br><span class="line">		<span class="keyword">this</span>.setState(state);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幸运的是通过结合ES6的两个功能：箭头函数和属性初始化，绑定到组件实例变得轻而易举。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	onChange = (state) =&gt; &#123;</span><br><span class="line">		<span class="comment">//this引用的是组件实例</span></span><br><span class="line">		<span class="keyword">this</span>.setState(state);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6箭头函数和其代码体共享同一个this，ES7的属性初始化在同一作用域。</p>
<h3 id="动态属性名和模板字符串">动态属性名和模板字符串</h3><p>给一个对象动态添加属性。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var MyReact = React.createClass(&#123;</span><br><span class="line">	<span class="keyword">on</span>Change: function(inputName, e) &#123;</span><br><span class="line">		var <span class="keyword">state</span>ToSet = &#123;&#125;;</span><br><span class="line">		<span class="keyword">state</span>ToSet[inputName + 'value'] = e.target.value;</span><br><span class="line">		this.<span class="built_in">set</span>State(<span class="keyword">state</span>ToSet);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当我们要动态添加的对象属性名称由运行时JavaScript表达式决定时候，我们使用模板字符串来设置属性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	onChange(inputName, e) &#123;</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">			[`$&#123;inputName&#125;value`]: e.target.value</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构与传播属性">解构与传播属性</h3><p>通常，在编写组件的时候，我们可能都会想着把父组件的props传递给子组件，但并不是所有的props。结合ES6的解构和JSX传播属性，很容易实现该功能。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="comment">//...others表示除cname外的其它属性</span></span><br><span class="line">		const &#123; cname, ...others&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div className=&#123;cname&#125;&gt;</span><br><span class="line">				&lt;<span class="type">Children</span> &#123;...others&#125; /&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/11/跨浏览器的事件处理/" itemprop="url">
                  跨浏览器的事件处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-11T17:42:26+08:00" content="2016-01-11">
              2016-01-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="跨浏览器的事件对象">跨浏览器的事件对象</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">	addHandler: function(element, type, handler) &#123;</span><br><span class="line">		<span class="keyword">if</span>(element.addEventListener) &#123;</span><br><span class="line">			element.addEventListener(type, handler, <span class="keyword">false</span>);</span><br><span class="line">		&#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span>(<span class="params">element.attachEvent</span>) </span>&#123;</span><br><span class="line">			element.attachEvent(<span class="string">'on'</span> + type, handler);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			element[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	getEvent: function(<span class="keyword">event</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">event</span> ? <span class="keyword">event</span> : window.<span class="keyword">event</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">	getTarget: function(<span class="keyword">event</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">event</span>.target || <span class="keyword">event</span>.srcElement;</span><br><span class="line">	&#125;,</span><br><span class="line">	preventDefault: function(<span class="keyword">event</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">event</span>.preventDefault) &#123;</span><br><span class="line">			<span class="keyword">event</span>.preventDefault();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">event</span>.returnValue = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	removeHandler: function(element, type, handler) &#123;</span><br><span class="line">		<span class="keyword">if</span>(element.removeEventListener) &#123;</span><br><span class="line">			element.removeEventListener(type, handler, <span class="keyword">false</span>);</span><br><span class="line">		&#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span>(<span class="params">element.detachEvent</span>) </span>&#123;</span><br><span class="line">			element.detachEvent(<span class="string">'on'</span> + type, handler);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			element[<span class="string">'on'</span> + type] = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	stopPropagation: function(<span class="keyword">event</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">event</span>.stopPropagation) &#123;</span><br><span class="line">			<span class="keyword">event</span>.stopPropagation();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">event</span>.cancelBubble = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//获取相关元素属性，只对mouseover和mouseout起作用</span></span><br><span class="line">	getRelatedTarget: function(<span class="keyword">event</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">event</span>.relatedTarget) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">event</span>.relatedTarget;</span><br><span class="line">		&#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params"><span class="keyword">event</span>.toElement</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">event</span>.toElement;</span><br><span class="line">		&#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params"><span class="keyword">event</span>.fromElement</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">event</span>.fromElement;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//获取按的鼠标的那个键</span></span><br><span class="line">	getButton: function(<span class="keyword">event</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(document.implementation.hasFeature(<span class="string">'mouseEvents'</span>, <span class="string">'2.0'</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">event</span>.button;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span>(<span class="keyword">event</span>.button) &#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">					<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//获取鼠标滚轮滚动的wheelDelta属性值</span></span><br><span class="line">	getWheelDelta: function(<span class="keyword">event</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">event</span>.wheelDelta) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">event</span>.wheelDelta;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="keyword">event</span>.detail*<span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//获取键盘按键的charCode属性，该属性存储的是按键字符的ASCII码</span></span><br><span class="line">	getCharCode: function(<span class="keyword">event</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">event</span>.charCode === <span class="string">'number'</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">event</span>.charCode;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">event</span>.keyCode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//获取剪切板里面的内容</span></span><br><span class="line">    getClipboardText: function(<span class="keyword">event</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> clipboardData = (<span class="keyword">event</span>.clipboardData || window.clipboardData);</span><br><span class="line">        <span class="keyword">return</span> clipboardData.getData(<span class="string">'text'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//设置剪切板里面的内容</span></span><br><span class="line">    setClipboardText: function(<span class="keyword">event</span>, <span class="keyword">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">event</span>.clipboardData) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">event</span>.clipboardData.setData(<span class="string">'text/plain'</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span>  <span class="title">if</span>(<span class="params">window.clipboardData</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> window.clipboardData.setData(<span class="string">'text'</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/11/MEAT的十大作用/" itemprop="url">
                  MEAT的十大作用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-11T17:40:46+08:00" content="2016-01-11">
              2016-01-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MEAT的十大作用">MEAT的十大作用</h2><h3 id="1_显示及排列中文">1 显示及排列中文</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-type"</span></span><br><span class="line">	<span class="attribute">content</span>=<span class="value">"text/html; charset=utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明：Content-Type ==&gt; 文件内容格式；<br>content内容为对文件的设置。</p>
<h3 id="2_让搜索引擎容易搜索到">2 让搜索引擎容易搜索到</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="property">name</span>=<span class="string">"KeyWords"</span> content=<span class="string">"css'home page' html"</span>&gt;</span><br><span class="line">&lt;meta <span class="property">name</span>=<span class="string">"KeyWords"</span> content=<span class="string">"javascript '白占宁'"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>说明：KeyWords ==&gt; 关键字，关键字中英文均可。</p>
<h3 id="3_关于网站内容描述">3 关于网站内容描述</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="property">name</span>=<span class="string">"Description"</span> content=<span class="string">"javascript教学课程"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>说明：Description ==&gt; 内容的主要描述</p>
<h3 id="4_标注网页作者">4 标注网页作者</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="property">name</span>=<span class="string">"Author"</span> content=<span class="string">"baizn"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>说明：本网页作者信息</p>
<h3 id="5_用何种编辑器完成的">5 用何种编辑器完成的</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="property">name</span>=<span class="string">"Generator"</span> content=<span class="string">"Mozilla/3.0Gold(Win95)[Netscape]"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>说明：Generator==&gt;编辑器</p>
<p>Mozilla/3.0Gold(Win95)[Netscape]编辑器版本说明</p>
<h3 id="6_网页何时完成">6 网页何时完成</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="property">name</span>=<span class="string">"Creation-Date"</span> content=<span class="string">"01-jan-2015 00:00:00"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>说明：Creation-Date ==&gt; 创建日期</p>
<h3 id="7_网页的有效期及不被Cache所限制">7 网页的有效期及不被Cache所限制</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"Expired"</span> <span class="attribute">content</span>=<span class="value">"01-jan-2015 00:00:00"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Pragma"</span> <span class="attribute">content</span>=<span class="value">"no-cache"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明：Expired ==&gt; 网页终止期限；</p>
<p>no_cache ==&gt; 不记录cache信息，网站没有记忆功能。</p>
<h3 id="8_网页作者的网址和邮箱">8 网页作者的网址和邮箱</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">rev</span>=<span class="value">"made"</span> <span class="attribute">href</span>=<span class="value">"mailto:baizn@xx.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">rev</span>=<span class="value">"made"</span> <span class="attribute">href</span>=<span class="value">"http://www.bzn.com"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明：rev ==&gt; 正向关联；<br>made ==&gt; 网页制造者；<br>href ==&gt; 邮箱或网址。</p>
<h3 id="9_网页自动换页">9 网页自动换页</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"refresh"</span> <span class="attribute">content</span>=<span class="value">"15; url:=http://www.bzn.com/"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明：refresh ==&gt; 更新或重加载；</p>
<p>15 ==&gt; 15秒执行下一动作；</p>
<p>url ==&gt; 指定跳转到此网页。</p>
<h3 id="10_进入或离开网页的特效（限IE）">10 进入或离开网页的特效（限IE）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"指定要换页特效发生的状况"</span> <span class="attribute">content</span>=<span class="value">"特效模式(Duration=特效持续时间, Transition=代替的特效)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明：http-equiv的取值<br>Page-Enter: 进入页面；<br>Page-Exit: 离开页面；<br>Site-Enter: 进入本网站；<br>Site-Exit: 离开本网站。<br>content取值<br>revealTrans: 指定换页特效；<br>blendTrans: 设定换页效果为混合。<br>Duration: 设定特效持续时间；<br>Transition: 以0－23代替特效。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/11/React中Props的传递/" itemprop="url">
                  React中Props的传递
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-11T17:38:09+08:00" content="2016-01-11">
              2016-01-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="传递Props">传递Props</h2><p>React里有一个非常常用的模式就是对组件做一层抽象。组件对外公开一个简单的属性［Props］来实现功能。</p>
<p>可以使用<strong>JSX展开属性</strong>来合并现有的props和其他值：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &lt;Component &#123;...<span class="keyword">this</span>.props&#125; more=<span class="string">"values"</span> /&gt;;</span><br></pre></td></tr></table></figure>
<p>如果不使用JSX，可以使用一些对象辅助方法如ES6的<strong>Object.assign</strong>或Underscore的<strong>_.extend</strong>。</p>
<h3 id="手动传递">手动传递</h3><p>大部分情况下应该显式地向下传递props，这样可以确保只公开你认为是安全的内部API的字集。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FancyCheckBox = React.createClass(&#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">var</span> fancyClass = <span class="keyword">this</span>.props.<span class="keyword">checked</span> ? <span class="string">'FancyChecked'</span> : <span class="string">'FancyUnchecked'</span>;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div className=&#123;fancyClass&#125; onClick=&#123;<span class="keyword">this</span>.props.onClick&#125;&gt;</span><br><span class="line">				&#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">	&lt;FancyCheckBox <span class="keyword">checked</span>=&#123;<span class="keyword">true</span>&#125; onClick=&#123;consoe.log.bind(console)&#125;&gt;</span><br><span class="line">		Hello world!</span><br><span class="line">	&lt;/FancyCheckBox&gt;,</span><br><span class="line">	document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>但如果还有name、title等很多属性时候怎么办呢？</p>
<h3 id="在JSX里使用_…_传递">在JSX里使用 … 传递</h3><p>有时把所有的属性都传下去是不安全的，这时可以使用的<strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="external">解构赋值</a></strong>中的剩余属性特性来把未知属性批量提取出来。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="keyword">checked</span>, ...other&#125; = <span class="keyword">this</span>.props;</span><br></pre></td></tr></table></figure>
<p>这样能确保把所有的props传下去，除了已经使用了的属性。</p>
<p>使用<strong>…</strong>特性重写上面的示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FancyCheckBox = React.createClass(&#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">var</span> &#123;<span class="keyword">checked</span>, ...other&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">		<span class="keyword">var</span> fancyClass = <span class="keyword">checked</span> ? <span class="string">'FancyChecked'</span> : <span class="string">'FancyUnchecked'</span>;</span><br><span class="line">		<span class="comment">//other包含&#123;onClick: console.log&#125; 但checked属性除外</span></span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div &#123;...other&#125; className=&#123;fancyClass&#125; /&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">	&lt;FancyCheckBox <span class="keyword">checked</span>=&#123;<span class="keyword">true</span>&#125; onClick=&#123;consoe.log.bind(console)&#125;&gt;</span><br><span class="line">		Hello world!</span><br><span class="line">	&lt;/FancyCheckBox&gt;,</span><br><span class="line">	document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="传递和使用同一个Props">传递和使用同一个Props</h3><p>如果组件需要使用一个属性又要往下传递，可以直接使用<strong>checked={checked}</strong>再传一次，这样做比传整个this.props对象要好，因为更利于重构和语法检查。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CheckBox = React.createClass(&#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">var</span> &#123;<span class="keyword">checked</span>, title, ...other&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">		<span class="keyword">var</span> box = <span class="keyword">checked</span> ? <span class="string">'ok'</span> : <span class="string">'no'</span>;</span><br><span class="line">		<span class="keyword">var</span> boxTitle = <span class="keyword">checked</span>: <span class="string">'X'</span> : <span class="string">'Y'</span>;</span><br><span class="line">		<span class="keyword">return</span>(</span><br><span class="line">			&lt;label&gt;</span><br><span class="line">				&lt;input &#123;...other&#125;</span><br><span class="line">					<span class="keyword">checked</span>=&#123;<span class="keyword">checked</span>&#125;</span><br><span class="line">					type=<span class="string">'checkbox'</span> /&gt;</span><br><span class="line">				&#123;title&#125;</span><br><span class="line">			&lt;/label&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/11/Redux详解/" itemprop="url">
                  Redux详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-11T17:33:49+08:00" content="2016-01-11">
              2016-01-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>redux是Facebook提出的flux架构的一种优秀实现，而且不局限于为react提供数据状态处理。它是零依赖的，可以配合其他任何框架或者类库一起使用。要配合react，还的引入react-redux。</p>
<h3 id="action">action</h3><p>数据来源不确定 ，我们需要专门的处理函数，在各个数据源里筛选真正需要的数据，不让那些无关紧要的、甚至是脏数据污染了全局数据对象。</p>
<p>这种对数据来源做萃取工作的函数，就叫action。action不是［数据预处理］的功能，而是在web应用中所有的数据与状态的变化，几乎都来自［事件］。</p>
<p>javascript中的事件：DOM事件、ajax、路由change、setTimeout定时器、自定义事件等。</p>
<h4 id="action与event(事件)的区别">action与event(事件)的区别</h4><p>在表单keyup事件中，只在e.keyCode等于回车键或取消键时，才出发一类action。DOM事件提供的数据是event对象，里面主要包括跟DOM相关的数据，我们无法直接合并到全局数据对象里，只是将需要的部分数据传入action函数而已。所以，<strong>是event响应函数里主动调用了action函数，并且传入它需要的数据。</strong></p>
<h3 id="reducer">reducer</h3><p>action仅仅是预处理，将脏数据筛选掉，但没有产生可以直接合并到全局对象的数据和结构，甚至可能只是提供了线索，表示［需要获取那些数据，但数据不在我这里］。action函数的设计，也为它［只提供线索］的做法提供了支持，action函数必须返回一个带有<strong>type</strong>属性的plain object。</p>
<h4 id="action函数的设计理念">action函数的设计理念</h4><blockquote>
<ul>
<li><p>action的参数用来筛选掉脏数据，调用action函数的人，有义务传入他需要的数据</p>
</li>
<li><p>action返回的plain object中包含属性为type常量值</p>
<blockquote>
<p><em>表明这个对象携带的其他数据应该被［如何］再处理
</em>或者不带其他数据，仅仅启示已有数据需要如何调整，或需要主要获取那些数据</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>reducer就是处理action函数返回的线索的［数据再处理函数］，action是［预处理函数］。</strong></p>
<p>由于action返回的数据有个固定的结构，所以reducer函数也有固定的结构。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//reducer函数接收两个参数:  全局数据对象<span class="keyword">state</span>以及action函数返回的action对象</span><br><span class="line">//返回新的全局数据对象new <span class="keyword">state</span></span><br><span class="line">export <span class="keyword">default</span>(<span class="keyword">state</span>, action) =&gt; &#123;</span><br><span class="line">	switch(action.type) &#123;</span><br><span class="line">		case A:</span><br><span class="line">			return handleA(<span class="keyword">state</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			return <span class="keyword">state</span>; //没有匹配上就直接返回原<span class="keyword">state</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reducer只是一个**匹配模式的东西，真正处理数据的函数，是写到别的地方，只在reducer中调用而已。</p>
<h4 id="为什么叫reducer函数">为什么叫reducer函数</h4><p>因为action对象各种各样，每种对应某个case，但最后都汇总到state对象，从多到一，是一个减少（reduce）的过程，所以完成这个过程的函数就叫<strong>reducer</strong>。</p>
<h3 id="combineReducers">combineReducers</h3><p>reducer的第一个参数是全局对象，因此state对象的树形结构必定会随着web应用的复杂性而变得越来越深，当action.type所对应的case只是修改state.a.b.c这个属性时，handleCase函数就会嵌套的特别深，必须在这个函数的头部验证state对象有没有那个属性。<br>需要如下模式：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这个reducer的<span class="keyword">state</span>属性不是全局<span class="keyword">state</span>本身</span><br><span class="line">//而是他的一个子代属性，如<span class="keyword">state</span>.todos这个对象</span><br><span class="line">//返回的new <span class="keyword">state</span>也会合并到<span class="keyword">state</span>.todos对象中</span><br><span class="line">export <span class="keyword">default</span> (<span class="keyword">state</span>, action) =&gt; &#123;</span><br><span class="line">	switch(action.type) &#123;</span><br><span class="line">		case B:</span><br><span class="line">			return newstate;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，写起来是普通的reducer，但获取的不是全局的state。</p>
<p><strong>实现方法：</strong>遍历一个［全是方法］的［函数储存对象］，返回新对象，这个新对象的key跟［函数储存对象］一样，它的value则是［函数储存对象］的同名方法接收(state[key], action)参数的返回值。</p>
<p>目前redux不提供映射到一级以上深度的state的方法，解决思路：</p>
<blockquote>
<ul>
<li>superGetter／superSetter</li>
<li>嵌套combineReducers</li>
<li>修改源码，使用模式走transformer</li>
</ul>
</blockquote>
<p>详情参考<a href="http://div.io/topic/1309" target="_blank" rel="external">这里</a>。</p>
<p>总的来说，combineReduers不是一个必需品，它只是用来分发对象的属性到各个reducer中去，如果觉得太绕，可以直接选择在每个handleCase函数中查询state属性，合成newState并返回即可，这时候，只需要一个reducers函数，它的switch语句处理所有可能的action.type。</p>
<h3 id="createStore">createStore</h3><p>action函数只返回一个普通对象，是谁把它传递到reducers(state, action)调用呢？reducers | state | action这三个由谁来协调？</p>
<p>此时，createStore(reducer,initialState)呼之欲出，它接收一个reducer函数跟initialState初始化的全局状态对象，返回几个［公共方法］：dispatch | getState | subscribe。</p>
<p>createStore的返回值是一个对象，通常保存在store这个变量名里。其实store只是一个方法，没有数据属性的对象，用JSON.stringify去序列化，得到的是空对象。真正的state包含在必包中，通过公用方法getState获取。</p>
<p>而dispatch方法，是store对象提供的更改currentState这个必包变量的唯一建议途径。</p>
<p>subscribe方法是一个简单的事件侦听方法，在dispatch里更新完currentState后调用，不管是什么action触发的更新，都会被调用，并且没有任何参数，只是告诉你state更新了。</p>
<h3 id="bindActionCreators">bindActionCreators</h3><p>通过createStore拿到了store，通过store.dispatch(action)我们可以免去手动调用reducer的负担，只处理action就可以了。这里有两种意义上的action，一种是action创建函数，一种是action对象，action创建函数接收参数并返回一个action对象。</p>
<p>action创建函数是工厂模式，专门生产action对象。所以通过重命名，更清晰的区分两者，action创建函数就叫actionCreator，它的返回值叫action。</p>
<p>store.dispatch(action)这里的action是对象，而不是函数，它是actionCreator返回的，所以实际上要这样调用store.dispatch(actionCreator(…args))。</p>
<p>原本的reducer(state, action)模式，用createStore(reducer, initalState)转换成store.dispatch(action)，发现还不够，再封装一层，这就是函数式思想的体现，通过反复组合，将多参数模式，转化成单参数模式。</p>
<h4 id="怎样组合">怎样组合</h4><blockquote>
<p>单个actionCreator，通过bindActionCreator。</p>
</blockquote>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将actionCreator和dispatch绑定</span></span><br><span class="line"><span class="keyword">let</span> bindActionCreat<span class="subst">or</span> =&gt; (actionCreat<span class="subst">or</span>, dispatch) &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="attribute">...</span>args) =&gt; dispatch(actionCreat<span class="subst">or</span>(<span class="attribute">...</span>args));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通工厂函数，返回一个对象</span></span><br><span class="line"><span class="keyword">let</span> addItem = text =&gt; (&#123;</span><br><span class="line">	<span class="keyword">type</span>: <span class="string">'ADD_ITEM'</span>,</span><br><span class="line">	text</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//跟store.dispatch绑定，成为真正可以改变currentState的action函数</span></span><br><span class="line"><span class="keyword">let</span> addItem = bindActionCreat<span class="subst">or</span>(addItem, store<span class="built_in">.</span>dispatch);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于多个actionCreator，可以像reducers一样，组成一个key/action组合。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> actionCreators === <span class="string">'function'</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> bindActionCreator(actionCreators, dispatch);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回一个改造过的[函数组合]</span></span><br><span class="line">	<span class="keyword">return</span> mapValues(actionCreators, actionCreator =&gt; bindActionCreator(actionCreator, dispatch))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，我们用bindActionCreator得到了真正具有改变全局state能力的许多函数，接下来就是将这些函数分发到各个地方，由各个event自主调用即可。</p>
<h3 id="redux工作流程">redux工作流程</h3><blockquote>
<p>首先，需要设计一些［常量］，因为action.type通常是字符串常量。为了便于集中管理，以及利于压缩代码，所以最好将常量单独放在单独的文件夹里，根据类型的不同放置在不同的文件夹中。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActionTypes.js 真正改动了数据的 actionType 在这里</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> ADD_ITEM = <span class="string">'ADD_ITEM'</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> DELETE_ITEM = <span class="string">'DELETE_ITEM'</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> DELETE_ITEMS = <span class="string">'DELETE_ITEMS'</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> UPDATE_ITEM = <span class="string">'UPDATE_ITEM'</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> UPDATE_ITEMS = <span class="string">'UPDATE_ITEMS'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//API.js 服务端接口统一放这里</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> API_TODOS = <span class="string">'/todos'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> SERVER_UPDATE = <span class="string">'SERVER_UPDATE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//KeyCode.js 键盘的回车键与取消键对应的编码</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> ENTER_KEY = <span class="number">13</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> ESCAPE_KEY = <span class="number">27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> FILTER_ITEMS = <span class="string">'FILTER_ITEMS'</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> SHOW_ALL = <span class="string">'SHOW_ALL'</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> SHOW_ACTIVE = <span class="string">'SHOW_ACTIVE'</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">const</span> SHOW_COMPLETED = <span class="string">'SHOW_COMPLETED'</span></span><br></pre></td></tr></table></figure>
<p>通过常量设计，可以清晰地反应出我们整个web应用的业务架构设计，这方面如果没设计好，随着应用复杂性的增加，会越来越难以维护。</p>
<blockquote>
<p>比设计常量更靠前的，是设计整个应用的state树的结构</p>
<p>有了常量，就可以写actionCreator了，它们被放置在actions文件里</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> * as types from <span class="string">'../constants/ActionTypes'</span></span><br><span class="line"></span><br><span class="line">export <span class="function"><span class="keyword">function</span> <span class="title">addItem</span><span class="params">(text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; type: types.ADD_ITEM, text &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>action是预处理，下一个环节是再处理函数reducer，它们被放置再reducers文件夹里</p>
</blockquote>
<h4 id="redux的流程">redux的流程</h4><blockquote>
<ul>
<li>设计全局state的数据结构</li>
<li>设计更改state数据的actionTypes常量以及其他跟视图展现相关的actionTypes常量</li>
<li>根据actionTypes常量，写actionCreator</li>
<li>根据各个actionCreator的返回值，涉及reducer做数据的最后处理</li>
<li>在有了reducer函数之后，creatorStore(reducer, initState)得到store对象</li>
<li>用bindActionCreators函数将actionCreators和store.dispatch绑定起来，得到一组能够修改全局状态的函数</li>
<li>分发各个状态修改函数到各个DOM事件中</li>
</ul>
</blockquote>
<h4 id="action_creator函数">action creator函数</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeActionCreator</span><span class="params">(type, <span class="rest_arg">...argNames</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">		let action = &#123;type&#125;;</span><br><span class="line">		argNames.forEach((arg, index) =&gt; &#123;</span><br><span class="line">			action[argNames[index]] = args[i];</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> action;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">const</span> addTodo = makeActionCreator(<span class="string">'ADD_TODO'</span>, <span class="string">'todo'</span>);</span><br></pre></td></tr></table></figure>
<p>参考资料：<a href="http://div.io/topic/1309" target="_blank" rel="external">深入到源码：解读 redux 的设计思路与用法 </a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="baizn" />
          <p class="site-author-name" itemprop="name">baizn</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">45</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">93</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">baizn</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
